그래프에서 자주 출제되는 문제 유형이다.   
크루스칼 알고리즘과 플루이드 와샬이 대표적인 그리디 알고리즘이다.   
그 중 여기서는 플로이드 워셜 알고리즘에 대해 알아보자.   
# 플로이드 워셜
플로이드 워셜 알고리즘은 '모든 지점'에서 '모든 지점'까지의 최단 경로를 모두 구해야할 때 사용할 수 있는 알고리즘이다.    
매번 방문하지 않은 노드중에서 최단 거리를 갖는 노드를 찾을 필요가 없다는 점에서 다익스트라와 다른점이라고 할 수 있다.   
총 N번의 단계를 수행하며, 수행하는 단계마다 O(N^2)의 연산을 통해 계산한다 따라서 N * O(N^2) -> O(N^3)의 시간복잡도를 가진다.      
   
   
해당 알고리즘이 동작하는 원리는 다음과 같다.   
현재 노드의 최솟값을 지정할 때 현재값과 다른 경로로 왔을때의 최솟값을 비교해서 넣어주는 방식이다.   
시작 -> 끝 이 20이더라도, 시작 -> 경유지 -> 끝이 15면 갱신해주는 방식을 반복해준다.  
   
   
<img width="215" alt="스크린샷 2023-11-20 오후 5 24 31" src="https://github.com/ww5702/Swift_Coding_Test/assets/60501045/ac818f89-a470-47eb-9c64-2ccb13f054d9">   
   
   
위의 그림을 예로 들 때, 1에서 5까지 가는 최소 비용은    
1 - 2 - 5 -> 비용 3이다.   
각 노드들마다 경유지로 지나치기 때문에 3중 반복문을 이용한다 n * n^2의 시간복잡도이기 때문이다.   
이제 핵심 코드를 알아보자.   
```
func Floyd_Warshall() {
  for i in 0..<N {
    for j in 0..<N {
      for k in 0..<N {
        node[j][k] = min(node[j][i] + node[i][j], node[j][k])
      }
    }
  }
}
```
코드가 복잡하지 않아 이해하는데는 어려움이 없을것이다.   
node[j][k]값과 node[j][i] + node[i][k]중 작은값을 결과값으로 지정한다.   
즉, j에서 k까지 갈때, i라는 경유지를 거쳐서 가는 경우를 비교하는 것이다.   
   
   
이제 알고리즘 문제를 예로 한번 풀어보자.   
아래 문제는 2021 KAKAO BLIND RECURITMENT - 합승 택시 요금이다.    

   
<img width="645" alt="스크린샷 2023-11-20 오후 5 32 53" src="https://github.com/ww5702/Swift_Coding_Test/assets/60501045/f0d97cef-c1ad-4e58-a956-90339e2fca72">   


쉽게 말해서 A와 B 두 사람이 있는데, 각자의 집은 A = 6, B = 2이다.   
그리고 출발지는 S (4)이다.   
함께 동행하면서 최소 비용은 구하고싶은 문제이다.   

   
먼저 각각의 노드에서 다른노드로 가는요금을 기록해놓을 2차원 배열을 만들어준다.   
```
var fee = [[Int]](repeating: [Int](repeating: 987654321, count: n + 1), count: n + 1)
var result = 987654321
for fare in fares {
   fee[fare[0]][fare[1]] = fare[2]
   fee[fare[1]][fare[0]] = fare[2]
}
for node in 1...n {
   fee[node][node] = 0
}
```   
자기 자신으로 가는 방법은 0이기에 꼼꼼히 해당 경로는 0으로 구현한다.   
위의 그림을 해당 코드로 돌려본다면   
```
[987654321, 987654321, 987654321, 987654321, 987654321, 987654321, 987654321]
[987654321, 0, 987654321, 41, 10, 24, 25]
[987654321, 987654321, 0, 22, 66, 987654321, 987654321]
[987654321, 41, 22, 0, 987654321, 24, 987654321]
[987654321, 10, 66, 987654321, 0, 987654321, 50]
[987654321, 24, 987654321, 24, 987654321, 0, 2]
[987654321, 25, 987654321, 987654321, 50, 2, 0]
```
위와 같은 모양이 된다. 1번 노드에서 3 4 5 6 노드로 가는 비용은 41 10 24 25가 든다는 의미이다.   
이제 여기서 플로이드 워셜 알고리즘을 사용한다.   
```
for k in 1...n {
   for i in 1...n {
      // i부터 j까지 가는데 k를 거쳐서 가는게 더 빠르다면 변경
      for j in 1...n {
         fee[i][j] = min(fee[i][j], fee[i][k]+fee[j][k])
      }
   }
}
```
위의 반복문을 통해 각 노드에서 각 노드들까지 가는 최소 거리를 알 수 있다.   
```
[987654321, 0, 63, 41, 10, 24, 25]
[987654321, 63, 0, 22, 66, 46, 48]
[987654321, 41, 22, 0, 51, 24, 26]
[987654321, 10, 66, 51, 0, 34, 35]
[987654321, 24, 46, 24, 34, 0, 2]
[987654321, 25, 48, 26, 35, 2, 0]
```
문제에서 나온 4번 출발노드를 예로 들면 4번 노드에서 각각의 목적지까지 드는 최소 비용은   
10, 66, 51, 0, 34, 35가 된다.   
이제 문제에서 원하는 대답을 구해낼 수 있다.   
중간까지 같이 간다는 문구를 활용하기 위해 Mid 변수를 이용해본다.   
출발지 -> mid + mid -> A목적지 + mid -> B목적지 가 최소인 값을 반환하면 된다.   
```
var result = Int.max!
for mid in 1...n {
   result = min(result, fee[s][mid]+fee[mid][a]+fee[mid][b])
}
```
그 결과 S(4)번에서 5번까지 함께 동행 (34) 하고,   
5번에서 2번(B)까지 B가 혼자(46)   
5번에서 6번(A)까지 A가 혼자(2)   
합 82가 최저비용으로 선택된다.   

***
이쯤에서 궁금한 점이 있다.   
시간복잡도가 O(N^3)인 알고리즘을 왜 알아야할까?   
다익스트라 알고리즘은 그래프에서 최단 거리를 찾는 가장 대표적인 알고리즘이다.   
특정시작지점에서 모든 노드까지의 최소 거리를 알 수 있는데   
그냥 N번 반복하여 각각의 노드를 전부 시작지점으로 설정해서 모든 노드로의 거리를 구하면 끝 아닌가?   
복잡도 또한 다익스트라 O(VlogV + E)에 N번 반복 = O(N(VlogV + E))이 될텐데 말이다.   
이유는 단순하다.   
플로이드 워셜 알고리즘은 다익스트라와 달리 가중치가 '음수'여도 가능하기 때문이다.   
하지만 3중 반복문의 크기는 상당히 크기 때문에 노드의 크기가 500 이상이라면 이용하기 쉽지 않다.   
