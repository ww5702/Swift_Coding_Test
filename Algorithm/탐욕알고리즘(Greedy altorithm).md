# 탐욕(그리디) 알고리즘(Greedy Algorithm)
그리디 알고리즘은 동적프로그래밍(dp) 사용 시 지나치게 많은 일을 한다는 것에서 착아하여 고안된 알고리즘이다.   
동적 프로그래밍을 대체하는 것은 아니고 같이 쓰면서 서로 보완하는 개념이다.   
탐욕 알고리즘 다른 이름으로는 욕심쟁이 알고리즘이라고도 불리는 이유는 미래를 생각하지 않고, 각 단계에서 가장 최선의 선택을 하는 기법이기 때문이다.   
즉, '선택의 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달한다' 라는 의미이다.   
그렇다면 조금만 생각하더라도 순간마다 하는 선택이 그 순간에는 최적이지만, 끝에 다달았을때에도 최적의 결과를 가져온다고는 판단 할 수없다는 사실을 알게된다.   
   
![image](https://user-images.githubusercontent.com/60501045/220325035-789ec9e2-29c2-4b0c-9279-1df93f59b5b5.png)   
   
위의 그림처럼 최대값을 구하는 값은 5 - 7 - 9 로 (21)의 값이 최대값을 가지게된다.   
하지만 탐욕알고리즘은 5 - 10 - 4 로 당시 상황에서 최대값을 따라가 최종값을 가져오게 된다.   

## 그리디 알고리즘의 조건(정당성) 2가지
1. 탐욕적 선택 속성 : 앞의 선택이 이후에 선택에 영향을 주지 않는다.
2. 최적 부분 구조 : 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다.   

***
따라서 '가장 큰 순서대로', '가장 작은 순서대로'와 같은 기준일 때 사용하기에 적절하다   
거스름돈 문제가 이에 대한 예시라고 볼 수 있다.   
500원, 100원, 50원, 10원을 최소의 개수로 거스름돈을 거슬러 준다고 가정하는 이와 같은 문제일 때 사용하기 적절하다.   
1260원을 거슬러 준다고 가정할 시   
```
var money: Int = 1260
var count = 0

let coin_type : [Int] = [500,100,50,10]

for i in coin_type {
	count += (money / i)
	money %= i
}
print(count)
```
이처럼 가장 큰 돈을 먼저, 작은돈을 나중으로 구하는 알고리즘이다.   
시간 복잡도는 O(n)이 된다.   
거스름돈 문제의 정당성은 동전의 단위가 모두 배수 형태라는 것이다. 만약에 거스름돈이 500원 400원이었으면 위와같은 해결방식은 사용할 수 없다.   
무작위로 주어지는 경우 동적프로그래밍을 사용해 풀이해야한다.   
***
   
## 그리디 알고리즘 문제를 해결하는 방법
1. 선택절차 : 현재 상태에서의 최적의 해답을 선택한다.
2. 적절성 검사 : 선택된 해가 문제의 조건을 만족하는지 검사한다.
3. 해답 검사 : 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 선택 절차로 돌아가 위의 과정을 반복한다.
