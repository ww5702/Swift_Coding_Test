그래프에서 자주 출제되는 문제 유형이다.   
크루스칼 알고리즘과 플루이드 와샬이 대표적인 그리디 알고리즘이다.   
그 중 여기서는 플로이드 와샬 알고리즘에 대해 알아보자.   
# 플로이드 와샬
플로이드 와샬 알고리즘은 '모든 지점'에서 '모든 지점'까지의 최단 경로를 모두 구해야할 때 사용할 수 있는 알고리즘이다.    
매번 방문하지 않은 노드중에서 최단 거리를 갖는 노드를 찾을 필요가 없다는 점에서 다익스트라와 다른점이라고 할 수 있다.   
총 N번의 단계를 수행하며, 수행하는 단계마다 O(N^2)의 연산을 통해 계산한다 따라서 N * O(N^2) -> O(N^3)의 시간복잡도를 가진다.      
   
   
해당 알고리즘이 동작하는 원리는 다음과 같다.   
현재 노드의 최솟값을 지정할 때 현재값과 다른 경로로 왔을때의 최솟값을 비교해서 넣어주는 방식이다.   
시작 -> 끝 이 20이더라도, 시작 -> 경유지 -> 끝이 15면 갱신해주는 방식을 반복해준다.  
   
   
<img width="215" alt="스크린샷 2023-11-20 오후 5 24 31" src="https://github.com/ww5702/Swift_Coding_Test/assets/60501045/ac818f89-a470-47eb-9c64-2ccb13f054d9">   
   
   
위의 그림을 예로 들 때, 1에서 5까지 가는 최소 비용은    
1 - 2 - 5 -> 비용 3이다.   
각 노드들마다 경유지로 지나치기 때문에 3중 반복문을 이용한다 n * n^2의 시간복잡도이기 때문이다.   
이제 핵심 코드를 알아보자.   
```
func Floyd_Warshall() {
  for i in 0..<N {
    for j in 0..<N {
      for k in 0..<N {
        node[j][k] = min(node[j][i] + node[i][j], node[j][k])
      }
    }
  }
}
```
코드가 복잡하지 않아 이해하는데는 어려움이 없을것이다.   
node[j][k]값과 node[j][i] + node[i][k]중 작은값을 결과값으로 지정한다.   
즉, j에서 k까지 갈때, i라는 경유지를 거쳐서 가는 경우를 비교하는 것이다.   
   
   
이제 알고리즘 문제를 예로 한번 풀어보자.   
아래 문제는 2021 KAKAO BLIND RECURITMENT - 합승 택시 요금이다.    

   
<img width="645" alt="스크린샷 2023-11-20 오후 5 32 53" src="https://github.com/ww5702/Swift_Coding_Test/assets/60501045/f0d97cef-c1ad-4e58-a956-90339e2fca72">   


   
