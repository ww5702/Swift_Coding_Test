# 다양한 그래프 알고리즘
이번에는 지금까지 다루지 않았던 그래프 알고리즘을 추가로 다룰 것이다.   
출제 비중은 낮지만 제대로 알고는 있어야 하는 알고리즘이다.   
예를 들어 크루스칼 알고리즘(그리디), 위상 정렬 알고리즘(큐,스택)등이 있다.   
그래프 자료구조는 그래프 혹은 트리로 풀이방법을 나눠 해결할 수 있는데   
어떤 문제를 만나든 메모리와 시간을 염두에 두고 알고리즘을 선택해 구현해야 한다는 것이다.   
예를 들어 최단 경로를 찾아야 하는 문제가 출제되었을 때, 노드의 개수가 적다면   
플로이드 워셜 알고리즘 즉 2차원 배열을 이용한 인접행렬을 이용해 풀이가 가능하지만   
노드와 간선의 개수가 모두 많으면 우선순위 큐를 이용하는 다익스트라 알고리즘을 이용하면 유용하다.   
   
## 서로소 집합 자료구조
서로소 집합이란 공통 원소가 없는 두 집합을 의미한다.   
{1,2} {3,4}는 서로 공통원소가 없으므로 서로소 관계이지만   
{1,2} {2,3}은 2라는 공통원소가 있으므로 서로소 관계가 아니라는 뜻이다.   
서로소 집합 자료구조를 구현할 때는 트리 자료구조를 이용해 집합을 표현하는데,   
합집합 연산(서로소 집합정보)가 주어졌을때 트리 자료구조를 이용해 집합을 표현하는 서로소 집합 계산 알고리즘은 다음과 같다.   
1. 합집합(union)연산을 확인하여 서로 연결된 두 노드 A,B를 확인한다.   
- A와 B의 루트노드 'A','B'를 각각 찾는다.
- A를 B의 부모 노드로 설정한다 (B를 A가 가리키도록 한다)
2. 모든 합집합(union) 연산을 처리할 때 까지 1번 과정을 반복한다.   
A가 1이고 B가 3이라면 B가 A를 가리키도록 설정한다.   
위의 말은 A가 B의 부모노드가 된다는 의미이다.   
예를 들어보자 {1,4} {2,3} {2,4} {5,6}의 합집합이 있다.   
먼저 1이 부모노드 4가 자식노드가 된다.   
2가 부모노드 3이 자식노드가 된다.   
{2,4}를 알아볼때 각 노드의 부모노드를 확인한다.   
각각의 부모노드는 2,1이므로 더 큰 번호에 해당하는 루트2의 부모노드를 1으로 설정한다.   
노드 번호 1 2 3 4 5 6   
부모 번호 1 1 2 1 - -   
{5,6}을 진행한다면   
노드 번호 1 2 3 4 5 6   
부모 번호 1 1 2 1 5 5   
최종적인 부모 번호가 위와 같이 설정된다.   
노드 3의 노드를 찾기 위해서는 먼저 부모 노드인 2로 이동한 다음 노드 2의 부모를 또 확인해 최종적으로 1으로 접근해야 한다.   
다시 말해 서로소 집합 알고리즘으로 루트 노드를 찾기 위해서는 재귀적으로 부모를 거슬러 올라간다는 뜻이다.   
코드로 구현해보자.   
```
import Foundation

func solution() {
    func find_parent(_ parent: [Int], _ x: Int) -> Int{
        if parent[x] != x {
            return find_parent(parent, parent[x])
        }
        return x
    }
    func union_parent(_ a: Int, _ b: Int) {
        let a = find_parent(parent, a)
        let b = find_parent(parent, b)
        if a < b {
            parent[b] = a
        } else {
            parent[a] = b
        }
    }
    
    let ve = readLine()!.split(separator: " ").map{Int($0)!}
    let (v,e) = (ve[0],ve[1])
    var parent = Array(repeating: 0, count: v+1)
    // 초기 자기자신은 i를 가르킨다
    for i in 1..<parent.count {
        parent[i] = i
    }
    //union 연산 수행
    for _ in 0..<e {
        let ab = readLine()!.split(separator: " ").map{Int($0)!}
        let (a,b) = (ab[0],ab[1])
        union_parent(a, b)
    }
    
    print("각 원소가 속한 집합 : ",terminator: " ")
    for i in 1..<v+1 {
        print(find_parent(parent, i), terminator: " ")
    }
    print()
    // 부모 테이블 출력
    print("부모 테이블 : ",terminator: " ")
    for i in 1..<v+1 {
        print(parent[i],terminator: " ")
    }
    
}
solution()
```
위와 같이 쉽게 구현이 되지만 find함수가 비효율적으로 동작한다.   
재귀적이기 때문에 운이 없다면 O(V)의 시간복잡도를 가지게 된다.   
find함수를 경로 압축 기법을 사용하여 최적화 시킨다.   
