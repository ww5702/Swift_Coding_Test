# 다이나믹 프로그래밍
컴퓨터 연산 속도에는 한계가 있고, 메모리 공간을 사용할 수 있는 데이터의 개수도 한정적이라는 점이 많은 제약을 발생시킨다.   
그래서 우리는 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성해야 한다.   
다만, 어떤 문제는 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법이 있다.   
대표적인 방법이 바로 이번 장에서 다루는 다이나믹 프로그래밍으로 동적 계획법일고도 한다.   
대표적으로 2가지 방식이 있는데 탑다운, 보텀업이 있고, 다이나믹 프로그래밍을 위해 자주 사용되는 메모이제이션 기법 또한 배워보자.   
   
다이나믹 프로그래밍으로 해결할 수 있는 대표적ㄹ인 예씨로 피보나치 수열이 있다.   
이전 두 항의 합을 현재의 항으로 설정하는 특징이 있는 수열이다.   
피보나치 수열의 점화식은 다음과 같이 표현할 수 있다.   
a(n+2) = a(n+1) + a(n)   
수학적 점화식을 프로그래밍으로 표현하려면 재귀함수를 사용하게 되는데 이를 소스코드로 바꾼다면 아래오 같다.   
```
import Foundation

func fibo(_ n: Int) -> Int{
    if n <= 1 { return 1 }
    return fibo(n-1) + fibo(n-2)
}
print(fibo(4))
```
하지만 위와 같은 방식으로 n이 커지게 된다면 기하급수적으로 값이 커지게 된다.   
O(2^n)의 공간복잡도이기에 n이 30이면 10억 가량의 연산을 수행해야 한다는 결론에 이른다.   
이처럼 재귀함수를 사용해 만들수는 있지만, 단순히 매번 계산 하도록 하면 문제를 효율적으로 해결할 수 없다.   
이럴 때 다이나믹 프로그래밍을 사용하면 효율적으로 해결할 수 있다.   
물론 항상 사용할수는 없으며, 다음의 조건을 만족할 때 사용할 수 있다.   
1. 큰 문제를 작은 문제로 나눌 수 있다.   
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.   
피보나치 수열을 메모이제이션 기법을 사용해서 해결해보자.   
메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, 한번 구한 결과를 메모리 공간에 메모해두고   
같은 식을 호출하면 메모한 결과를 그대로 가져오는 법을 의미한다.   
재귀적으로 수행하다가 같은 정보가 필요할때는 이미 구한 정답을 리스트에서 가져오면 된다.   
```
import Foundation
func solution() {
    var memory = Array(repeating: 0, count: 100)
    func fibo(_ n: Int) -> Int {
        if n == 1 || n == 2 { return 1}
        if memory[n] != 0 {
            return memory[n]
        }
        memory[n] = fibo(n-1) + fibo(n-2)
        return memory[n]
    }
    
    print(fibo(10))
}
solution()
```
다이나믹 프로그래밍을 적용했을 때의 피보나치 수열 알고리즘의 시간 복잡도는 O(N)이다.   
왜냐면 f(2)를 풀때 f(1)이 사용되고 f(3)을 풀때 f(2)가 사용되기 떄문이다.   
이처럼 재귀함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여   
탑 다운 방식이라고 한다.   
반면에 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 보텀업 방식이라고 말한다.   
피보나치 수열을 보텀업 즉 아래에서 위로 올라가는 방식으로 푼다면 다음과 같다.   
```
import Foundation
func solution() {
    var arr = Array(repeating: 0, count: 100)
    arr[1] = 1
    arr[2] = 1
    let n = 30
    for i in 3..<n+1 {
        arr[i] = arr[i-1] + arr[i-2]
    }
    print(arr[n])
    
}
solution()
```
보다시피 방식은 동일하다.   
단순히 반복문을 이용하여 아래에서 위로 올라간 모습을 확인할 수 있다.   
해당 방식은 '하향식'이라고도 하며, 보텀업 방식은 '상향식'이라고도 한다.   
다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다.   
메모이제이션 방식은 탑다운 방식에 국한되어 사용되는 표현이다.   
다이나믹 프로그래밍과 메모이제이션 개념을 혼용해서 사용하는 경우도 있는데,   
엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓은 넓은 개념을 의미하므로, 별도의 개념이다.   
특정한 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는지 확인해보자.   
또한 메모이제이션을 적용할 수 있다면 코드를 개선하는 방법도 좋은 아이디어이다.   
또한 가능하다면 재귀함수를 사용하는 탑다운 방식보다 보텀업 방식으로 구현하는 것을 권장한다.   
시스템상 재귀함수의 스택 크기가 한정되어있을수도 있기 때문이다.   
   
## 1로 만들기
정수 x에 사용할 수 있는 연산은 다음과 같이 4가지다.   
1. x가 5로 나누어 떨어지면, 5로 나눈다.   
2. x가 3으로 나누어 떨어지면, 3으로 나눈다.    
3. x가 2로 나누어 떨어지면, 2로 나눈다.   
4. x에서 1을 뺀다.   
x가 주어졌을 때 연산 4개를 적절히 사용해서 1을 만드려고 한다.   
최솟값을 출력하시오.   
   
해당 문제는 잘 알려진 다이나믹 프로그래밍 문제이다.   
피보나치 수열을 도식화했던것처럼 문제를 풀기 전에 함수가 호출되는 과정을 그림으로 그려보면 이해하는데 도움이 된다.   
f(6)의 경우 2,3,4번의 공식을 다 쓸수있다.   
f(5)가 될수도 f(3), f(2)가 될수도 있다.   
그리고 f(5), f(3), f(2)는 전부 중복된 값을 필요로 한다.   
해당 문제에서 다이나믹 프로그래밍을 효과적으로 사용할 수 있다는 것이다.   
점화식은 다음과 같다.   
a(i) = min(a(i-1), a(i/2), a(i/3), a(i/5)) + 1   
1을 더해주는 이유는 함수의 호출횟수를 구해야 하기 때문이다.   
6의 경우 5에서 1을 더해졌을수도, 3에서 2를 곱해졌을수도 있는데   
둘중 더 작은 횟수로 도달해야하므로 항상 min으로 최소값을 더해가며 보텀업 방식을 사용한다.   
