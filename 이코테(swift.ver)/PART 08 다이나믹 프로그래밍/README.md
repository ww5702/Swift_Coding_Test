# 다이나믹 프로그래밍
컴퓨터 연산 속도에는 한계가 있고, 메모리 공간을 사용할 수 있는 데이터의 개수도 한정적이라는 점이 많은 제약을 발생시킨다.   
그래서 우리는 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성해야 한다.   
다만, 어떤 문제는 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법이 있다.   
대표적인 방법이 바로 이번 장에서 다루는 다이나믹 프로그래밍으로 동적 계획법일고도 한다.   
대표적으로 2가지 방식이 있는데 탑다운, 보텀업이 있고, 다이나믹 프로그래밍을 위해 자주 사용되는 메모이제이션 기법 또한 배워보자.   
   
다이나믹 프로그래밍으로 해결할 수 있는 대표적ㄹ인 예씨로 피보나치 수열이 있다.   
이전 두 항의 합을 현재의 항으로 설정하는 특징이 있는 수열이다.   
피보나치 수열의 점화식은 다음과 같이 표현할 수 있다.   
a(n+2) = a(n+1) + a(n)   
수학적 점화식을 프로그래밍으로 표현하려면 재귀함수를 사용하게 되는데 이를 소스코드로 바꾼다면 아래오 같다.   
```
import Foundation

func fibo(_ n: Int) -> Int{
    if n <= 1 { return 1 }
    return fibo(n-1) + fibo(n-2)
}
print(fibo(4))
```
하지만 위와 같은 방식으로 n이 커지게 된다면 기하급수적으로 값이 커지게 된다.   
O(2^n)의 공간복잡도이기에 n이 30이면 10억 가량의 연산을 수행해야 한다는 결론에 이른다.   
이처럼 재귀함수를 사용해 만들수는 있지만, 단순히 매번 계산 하도록 하면 문제를 효율적으로 해결할 수 없다.   
이럴 때 다이나믹 프로그래밍을 사용하면 효율적으로 해결할 수 있다.   
물론 항상 사용할수는 없으며, 다음의 조건을 만족할 때 사용할 수 있다.   
1. 큰 문제를 작은 문제로 나눌 수 있다.   
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.   
피보나치 수열을 메모이제이션 기법을 사용해서 해결해보자.   
메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, 한번 구한 결과를 메모리 공간에 메모해두고   
같은 식을 호출하면 메모한 결과를 그대로 가져오는 법을 의미한다.   
재귀적으로 수행하다가 같은 정보가 필요할때는 이미 구한 정답을 리스트에서 가져오면 된다.   
```
import Foundation
func solution() {
    var memory = Array(repeating: 0, count: 100)
    func fibo(_ n: Int) -> Int {
        if n == 1 || n == 2 { return 1}
        if memory[n] != 0 {
            return memory[n]
        }
        memory[n] = fibo(n-1) + fibo(n-2)
        return memory[n]
    }
    
    print(fibo(10))
}
solution()
```
다이나믹 프로그래밍을 적용했을 때의 피보나치 수열 알고리즘의 시간 복잡도는 O(N)이다.   
왜냐면 f(2)를 풀때 f(1)이 사용되고 f(3)을 풀때 f(2)가 사용되기 떄문이다.   
이처럼 재귀함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여   
탑 다운 방식이라고 한다.   
반면에 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 보텀업 방식이라고 말한다.   
피보나치 수열을 보텀업 즉 아래에서 위로 올라가는 방식으로 푼다면 다음과 같다.   
```
import Foundation
func solution() {
    var arr = Array(repeating: 0, count: 100)
    arr[1] = 1
    arr[2] = 1
    let n = 30
    for i in 3..<n+1 {
        arr[i] = arr[i-1] + arr[i-2]
    }
    print(arr[n])
    
}
solution()
```
보다시피 방식은 동일하다.   
단순히 반복문을 이용하여 아래에서 위로 올라간 모습을 확인할 수 있다.   
해당 방식은 '하향식'이라고도 하며, 보텀업 방식은 '상향식'이라고도 한다.   
다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식이다.   
메모이제이션 방식은 탑다운 방식에 국한되어 사용되는 표현이다.   
다이나믹 프로그래밍과 메모이제이션 개념을 혼용해서 사용하는 경우도 있는데,   
엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓은 넓은 개념을 의미하므로, 별도의 개념이다.   
특정한 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는지 확인해보자.   
또한 메모이제이션을 적용할 수 있다면 코드를 개선하는 방법도 좋은 아이디어이다.   
또한 가능하다면 재귀함수를 사용하는 탑다운 방식보다 보텀업 방식으로 구현하는 것을 권장한다.   
시스템상 재귀함수의 스택 크기가 한정되어있을수도 있기 때문이다.   
   
## 1로 만들기
정수 x에 사용할 수 있는 연산은 다음과 같이 4가지다.   
1. x가 5로 나누어 떨어지면, 5로 나눈다.   
2. x가 3으로 나누어 떨어지면, 3으로 나눈다.    
3. x가 2로 나누어 떨어지면, 2로 나눈다.   
4. x에서 1을 뺀다.   
x가 주어졌을 때 연산 4개를 적절히 사용해서 1을 만드려고 한다.   
최솟값을 출력하시오.   
   
해당 문제는 잘 알려진 다이나믹 프로그래밍 문제이다.   
피보나치 수열을 도식화했던것처럼 문제를 풀기 전에 함수가 호출되는 과정을 그림으로 그려보면 이해하는데 도움이 된다.   
f(6)의 경우 2,3,4번의 공식을 다 쓸수있다.   
f(5)가 될수도 f(3), f(2)가 될수도 있다.   
그리고 f(5), f(3), f(2)는 전부 중복된 값을 필요로 한다.   
해당 문제에서 다이나믹 프로그래밍을 효과적으로 사용할 수 있다는 것이다.   
점화식은 다음과 같다.   
a(i) = min(a(i-1), a(i/2), a(i/3), a(i/5)) + 1   
1을 더해주는 이유는 함수의 호출횟수를 구해야 하기 때문이다.   
6의 경우 5에서 1을 더해졌을수도, 3에서 2를 곱해졌을수도 있는데   
둘중 더 작은 횟수로 도달해야하므로 항상 min으로 최소값을 더해가며 보텀업 방식을 사용한다.   
   
## 개미 전사
개미 전사는 부족한 식량을 충당하고자 메뚜기 마을의 식량창고를 몰래 공격하려고 한다.   
메뚜기 마을에는 여러개의 식량창고가 있는데 일직선으로 이어져있다.   
각 식량창고는 정해진 수의 식량을 저장하고 있으며, 개미전사는 식량창고를 선택적으로 약탈하여 식량을 빼앗을 예정이다.   
이때 메뚜기 정찰병들은 일직선상에 존재하는 식량창고 중에서 서로 인접한 식량창고가 공격받으면 알아차릴 수 있다.   
따라서 개미 전사가 정찰병에게 들키지 않고 식량창고를 약탈하기 위해서는 최소한 한 칸 이상 떨어진 식량창고를 약탈해야한다.   
1, 3, 1, 5의 식량창고가 존재한다면   
2번쨰와 4번째 식량창고를 털어야 최대값으로 식량을 털 수 있다.   
주어진 식량창고중 식량을 최대로 털 수 있는 프로그램을 작성하시오.   
   
왼쪽부터 차례대로 식량 창고를 턴다고 가정한다면 생각보다 쉽게 점화식을 구할 수 있다.   
1번 창고를 털 경우 2번 창고를 털지 못하고,   
2번 창고를 털 경우 1번 3번 창고를 털지 못한다.   
따라서 cache 배열 1번에 식량창고 1번을, 배열 2번에는 (1번을 무시하고 2번을 터는 경우 or 1번을 털고 2번을 털지 않는 경우) 가 존재한다.   
위를 정리한다면 arr[1] = max(food[1], food[2])가 되는것이고   
3번 부터는 1번을 턴것과 3번을 턴것 vs 2번을 털고 3번을 무시했을때 둘중 더 큰것을 골라주기만 하면 되는 문제이다.   
arr[2] = max(arr[1], arr[0]+food[2])   
   
## 바닥 공사
가로 N 세로 2인 직사각형 형태의 얇은 바닥이 있다. 
해당 바닥을 1x2 2x1 2x2의 덮개를 이용해 채우려고 한다.   
이때 바닥을 채우는 모든 경우의 수를 구하는 프로그램을 작성하시오   
   
해당 문제 또한 다이나믹 프로그래밍의 기초예제에서 빠지지 않는 문제 유형이다.   
다이나믹 프로그래밍 문제에서는 종종 결과를 어떤 수로 나눈 결과를 출력하라는 내용이 들어가 있는 경우가 많다.   
이 문제에서도 796, 796으로 나눈 나머지를 출력하라고 하는데, 이는 단지 결괏값이 굉장히 커질 수 있기 때문이다.   
모를때는 일단 예제를 만들어보며 점화식을 만들어 간다면 해결할 수도 있다.   
만약 n이 3이라면 3x2의 직사각형 판이 존재하는데   
1. 1x2, 2x2   
2. 2x1, 1x2   
3. 1x2, 1x2, 1x2    
4. 1x2, 옆으로 눞혀서 1x2, 1x2
5. 옆으로 눞혀서 1x2,1x2, 그냥 1x2
   
이를 정리한다면 왼쪽부터 차례대로 바닥을 덮개로 채운다고 생각하면 i-1까지 위의 경우로 채워져있을때   
한칸이 늘었다면 1x2 한칸으로 밖에 채우지 못하고   
두칸이 늘었다면 2x1한칸 or 눞힌 1x2 2개 로 채울 수 있다. (눞히지않은 1x2 두개는 이미 위에서 고려했을것이라 제외)   
그렇다면 i-3번째 부터는   
i-1에서 2가지 경우의 수로 늘어났을때 + i-2에서 1가지 경우로 늘어났을때 이다.   
i = (i-1) + (i-2)x2   
   
## 효율적인 화폐 구성
N가지 종류의 화폐가 있다.   
이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다.   
이때 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다.   
불가능할 땐 -1을 출력한다.   
   
이번 문제는 적은 금액부터 큰 금액까지 확인하며 차레대로 만들 수 있는 최소한의 화폐 개수를 찾으면 된다.   
금액 i를 만들 수 있는 최소한의 화폐 개수를 a(i) 단위를 k라고 했을 때 다음과 같은 점화식을 작성할 수 있다.   
해당 문제를 n = 3, m = 7, k = 2,3,5 인 main과 같이 풀었다면 cache인 d는 아래의 순서로 변화가 있게 된다.   
[0, 10001, 1, 10001, 2, 10001, 3, 10001]
[0, 10001, 1, 1, 2, 2, 2, 3]
[0, 10001, 1, 1, 2, 1, 2, 2]
2로 나눠지는 1행은 2 4 6에 전에 비해 1씩 커지는 경우이고   
3으로 나눠지는 2행은 3원을 받는다면 1씩 커지는 위치에 min을 이용해 2로 이미 더 적게 만들 수 있다면 해당 값으로 저장을   
5로 나눠지는 5행은 5원을 받는다면 1씩 커지게 만드는데 min을 이용해 2나 3으로 더 적게 만들 수 있다면 해당값으로 저장을 만들어 준다.   
