# 첫번째 풀이
## 모험가 길드
1차   
모험가의 공포도를 오름차순으로 정렬한 뒤   
count를 하나씩 늘리고 공포도보다 크거나 같으면 그룹을 +1 그리고 count를 초기화 해준다.   
그렇다면 최대의 그룹을 만들 수 있다.   
   
   
## 곱하기 혹은 더하기
1차   
입력받은 수를 배열로 나눈 뒤   
0일때와 1일때는 +를 나머지 수일때는 x를 해주면 최대값이 된다.   
   
## 문자열 뒤집기
1차   
어차피 전체를 뒤집는 행동은 의미가 없다고 판단하였다.   
그렇다면 0을 뒤집거나 1을 뒤집는 것중 더 작은값을 고르면 된다고 판단.   
count1, count0을 선언해 연속되다가 1이나 0으로 바뀌는 순간에 count0,count1을 각각 +   
해당 값들 중 min값을 선택   
   
## 만들 수 없는 금액
1차   
주어진 동전의 값들을 내림차순으로 정렬한 뒤 순차적으로 돌면서 점진적으로 증가하는 값 (1,2,3...)이 빼지는지 확인   
전부 돌았는데도 값이 0이 안되었다면 return   
   
## 볼링공 고르기
1차   
1,3을 돌려서 3,1로 다시 고를 수 없기 때문에 combination 즉 조합을 이용해 풀어야 한다.   
파이썬에는 combination 라이브러리가 있으나 스위프트에는 없기에 다르게 구현해준다.   
공의 무게는 1~10으로 정해져 있으므로 총 10개의 array를 만들어 준다.   
주어진 무게의 개수를 array에 + 해주고,
문제를 예시로 들면 1을 제외하고 나머지사람이 고를 수 있는 경우의 수는 5 - 1 이므로 1 x 4.  
그리고 1을 다시 고를 수 없게 하기 위해 n - 1.  
다음 첫번 째 사람이 2를 고를 경우는 2가지, 나머지 사람이 같은 무게는 들지 못하면서 다른 수를 고를 경우는 2 - 2 따라서 2 x 2   
마지막 3을 고를 수 있는 경우는 2가지, 이지만 n이 0이 됬으므로 더해지는 값은 없다.   
   
## 무지의 먹방 라이브
1차   
해당 문제는 한번에 풀지 못했다.   
먼저 food_times에 공통적으로 한번씩 먹을 경우의 수를 구한다.   
예시를 기준으로 한다면 1씩은 무조건 먹을 수 있으므로   
해당 값을 구하는 공식을 만들어주고, 3만큼을 k에 빼준다.   
루프를 돌리고도 못 먹은 음식들의 인덱스를 오름차순으로 정렬하고, 다시 진행시켜서 값을 구해준다.   
