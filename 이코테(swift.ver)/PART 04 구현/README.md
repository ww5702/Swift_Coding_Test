# 아이디어를 코드로 바꾸는 구현
코테에서 구현이란 '머리속에 있는 알고리즘을 소스코드로 바꾸는 과정'이다.   
어떤 문제를 풀든 간에 소스코드를 작성하게 되는데 문제를 읽고 문제 풀이 방법을 고민한다.   
물론 정확한 풀이 방법이 떠올랐다면 해당 방법을 코드로 정확히 구현해냈을 때 비로소 정답 처리를 받게 된다.   
   
흔히 문제 해결 분야에서 구현 유형의 문제는 '풀이를 떠올리는 것은 쉽지만 소스코드를 옮기기 어려운 문제'를 의미한다.   
언어의 문법에 능숙하고 코드 작성 속도가 빠른 사람이 곧 구현 실력이 좋은 개발자를 뜻한다.   
에를 들어 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제,   
문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 넣어야 하는(파싱) 문제 등   
까다로운 구현 유형의 문제가 구현하기 어려운 문제라고 할 수 있다.   
   
우리는 해당 문제들을 '모든 경우의 수를 주저없이 다 계산하여 해결하는' 완전 탐색 알고리즘과   
'문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행'하는 시뮬레이션 을 배우려고 한다.   
   
## 상하좌우
여행가 A는 N x N 크기의 정사각형 공간 위에 있다.   
가장 위 좌표는 (1,1)이며, 가장 오른쪽 아래 좌표는 (N,N)에 해당한다.   
여행자는 상, 하, 좌, 우 로 이동할 수 있으며, 시작 좌표는 항상 (1,1)이다.   
L(left), R(right), U(up), D(down)으로 이동할 수 있다.   
여행자는 NxN 크기의 공간을 벗어나면 움직임은 무시된다.   
무산되는 움직임을 제외하고 여행자가 입력한 움직임을 행했을때 위치할 좌표를 구하는 문제이다.   
5, (R R R U D D)이라면 4번째의 U는 정사각형을 벗어나므로 무산되고 최종 좌표는 (3,4)가 된다.   
   
해당 문제는 연산횟수가 이동 횟수에 비례하게 된다.   
따라서 이동횟수가 N이라면 O(N)만큼의 시간복잡도를 가지게 된다.   
코테에서 가장 난이도가 낮은 1~2번의 문제는 대부분 그리디, 구현 문제로 구성되어있다.   
논리적 사고력을 확인할 수 있기에 기본문제로 적합하다. 따라서 무조건 풀어야하는 문제라고도 할 수 있다.   
   
## 시각
정수 N이 입력되면 00시 00분 00초 부터 N시 59분 59초까지의 모든 시각 중에서   
3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하시오.   
이 문제는 모든 시각의 경우를 하나씩 모두 세서 쉽게 풀 수 있는 문제이다.   
하루는 86,400초로 00시 00분 00초 부터 23시 59분 59초 까지의 모든 경우의 수는 86,400개로 적은 편에 속한다.   
즉 시간, 분, 초 3중 반복문을 통해 풀어도 2초 안에 풀 수 있다는 결론에 다다른다.   
이러한 유형은 '완전 탐색' 유형으로 분류 되기도 한다.   
가능한 경우의 모든 수를 탐색하기 때문이다.   
물론 비효율적인 시간 복잡도를 가지고 있으므로 데이터 개수가 큰 경우에는 정상적으로 동작하지 않을 수 있다.   
따라서 100만 개 이하일 때 완전 탐색을 사용하면 적절하다.   
   
## 왕실의 나이트
왕실 정원은 체스판과 같이 8 x 8 좌표 평면으로 이루어져있다.   
왕실 정원의 특정한 한 칸에 나이트가 서 있다.   
나이트는 말을 타고 있기 때문에 이동을 할 때는 L자 형태로만 이동할 수 있으며, 정원 밖으로는 나갈 수 없다.   
나이트는 특정한 위치에서 다음과 같은 2가지 경우로 이동할 수 있다.   
1. 수평으로 두칸 이동한 뒤 수직으로 한칸 이동
2. 수직으로 두칸 이동한 뒤에 수평으로 한칸 이동
이처럼 평면상에 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하시오.   
행은 1~8으로 열은 a~h로 표현한다.   
만약 나이트가 a1에 위치한다면, 이동할 수 있는 경우의 수는 2가지이다.   
1. 오른쪽 두칸 이동 후 아래로 한칸 이동하기 (c2)
2. 아래로 두칸 이동 후 오른쪽으로 한칸 이동하기(b3)
   
해당 문제는 입력한 a1을 a와 1을 따로 저장 후   
아스키코드나 유니코드 스칼라로 정수로 변환시키고   
last나 first가 character형이기에 string형으로 변환시킨 후 int형으로 다시 변환시켜   
이동 가능한 steps를 파악해 [(-2,-1),(-2,1),(-1,-2),(-1,2),(2,-1),(2,1),(1,-2),(1,2)]   
반복문으로 해당 steps들을 완전 탐색하면서 이동했을때 1보다 크거나 8보다 작으면 += 1을 해주면 쉽게 풀릴 수 있다.   
⭐️ UnicodeScalar(값).value 했을때 대문자A는 65부터, 소문자a는 97부터 시작하게 된다.   
