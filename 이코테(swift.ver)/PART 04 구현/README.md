# 아이디어를 코드로 바꾸는 구현
코테에서 구현이란 '머리속에 있는 알고리즘을 소스코드로 바꾸는 과정'이다.   
어떤 문제를 풀든 간에 소스코드를 작성하게 되는데 문제를 읽고 문제 풀이 방법을 고민한다.   
물론 정확한 풀이 방법이 떠올랐다면 해당 방법을 코드로 정확히 구현해냈을 때 비로소 정답 처리를 받게 된다.   
   
흔히 문제 해결 분야에서 구현 유형의 문제는 '풀이를 떠올리는 것은 쉽지만 소스코드를 옮기기 어려운 문제'를 의미한다.   
언어의 문법에 능숙하고 코드 작성 속도가 빠른 사람이 곧 구현 실력이 좋은 개발자를 뜻한다.   
에를 들어 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제,   
문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에 넣어야 하는(파싱) 문제 등   
까다로운 구현 유형의 문제가 구현하기 어려운 문제라고 할 수 있다.   
   
우리는 해당 문제들을 '모든 경우의 수를 주저없이 다 계산하여 해결하는' 완전 탐색 알고리즘과   
'문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행'하는 시뮬레이션 을 배우려고 한다.   
   
## 상하좌우
여행가 A는 N x N 크기의 정사각형 공간 위에 있다.   
가장 위 좌표는 (1,1)이며, 가장 오른쪽 아래 좌표는 (N,N)에 해당한다.   
여행자는 상, 하, 좌, 우 로 이동할 수 있으며, 시작 좌표는 항상 (1,1)이다.   
L(left), R(right), U(up), D(down)으로 이동할 수 있다.   
여행자는 NxN 크기의 공간을 벗어나면 움직임은 무시된다.   
무산되는 움직임을 제외하고 여행자가 입력한 움직임을 행했을때 위치할 좌표를 구하는 문제이다.   
5, (R R R U D D)이라면 4번째의 U는 정사각형을 벗어나므로 무산되고 최종 좌표는 (3,4)가 된다.   
   
해당 문제는 연산횟수가 이동 횟수에 비례하게 된다.   
따라서 이동횟수가 N이라면 O(N)만큼의 시간복잡도를 가지게 된다.   
코테에서 가장 난이도가 낮은 1~2번의 문제는 대부분 그리디, 구현 문제로 구성되어있다.   
논리적 사고력을 확인할 수 있기에 기본문제로 적합하다. 따라서 무조건 풀어야하는 문제라고도 할 수 있다.   
   
## 시각
정수 N이 입력되면 00시 00분 00초 부터 N시 59분 59초까지의 모든 시각 중에서   
3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하시오.   
이 문제는 모든 시각의 경우를 하나씩 모두 세서 쉽게 풀 수 있는 문제이다.   
하루는 86,400초로 00시 00분 00초 부터 23시 59분 59초 까지의 모든 경우의 수는 86,400개로 적은 편에 속한다.   
즉 시간, 분, 초 3중 반복문을 통해 풀어도 2초 안에 풀 수 있다는 결론에 다다른다.   
이러한 유형은 '완전 탐색' 유형으로 분류 되기도 한다.   
가능한 경우의 모든 수를 탐색하기 때문이다.   
물론 비효율적인 시간 복잡도를 가지고 있으므로 데이터 개수가 큰 경우에는 정상적으로 동작하지 않을 수 있다.   
따라서 100만 개 이하일 때 완전 탐색을 사용하면 적절하다.   
   
## 왕실의 나이트
왕실 정원은 체스판과 같이 8 x 8 좌표 평면으로 이루어져있다.   
왕실 정원의 특정한 한 칸에 나이트가 서 있다.   
나이트는 말을 타고 있기 때문에 이동을 할 때는 L자 형태로만 이동할 수 있으며, 정원 밖으로는 나갈 수 없다.   
나이트는 특정한 위치에서 다음과 같은 2가지 경우로 이동할 수 있다.   
1. 수평으로 두칸 이동한 뒤 수직으로 한칸 이동
2. 수직으로 두칸 이동한 뒤에 수평으로 한칸 이동
이처럼 평면상에 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하시오.   
행은 1 ~ 8으로 열은 a ~ h로 표현한다.   
만약 나이트가 a1에 위치한다면, 이동할 수 있는 경우의 수는 2가지이다.   
1. 오른쪽 두칸 이동 후 아래로 한칸 이동하기 (c2)
2. 아래로 두칸 이동 후 오른쪽으로 한칸 이동하기(b3)
   
해당 문제는 입력한 a1을 a와 1을 따로 저장 후   
아스키코드나 유니코드 스칼라로 정수로 변환시키고   
last나 first가 character형이기에 string형으로 변환시킨 후 int형으로 다시 변환시켜   
이동 가능한 steps를 파악해 [(-2,-1),(-2,1),(-1,-2),(-1,2),(2,-1),(2,1),(1,-2),(1,2)]   
반복문으로 해당 steps들을 완전 탐색하면서 이동했을때 1보다 크거나 8보다 작으면 += 1을 해주면 쉽게 풀릴 수 있다.   
⭐️ UnicodeScalar(값).value 했을때 대문자A는 65부터, 소문자a는 97부터 시작하게 된다.   
   
## 게임 개발
게임 캐릭터가 맵 안에서 움직이는 시스템을 개발 중이다.   
캐릭터는 N X M 크기의 직사각형을 움직이고, 각각의 칸은 육지 또는 바다이다.   
캐릭터는 동 서 남 북 중 한곳을 바라본다.   
맵은 각 칸 (A,B)로 나타낼 수 있고, A는 북쪽으로부러 떨어진 칸의 개수, B는 서쪽으로부터 떨어진 칸의 개수이다.   
캐릭터는 상하좌우로 움직일 수 있고, 바다로 되어 있는 공간에는 갈 수 없다.   
메뉴얼은 이러하다.   
1. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향부터 차례대로 갈곳을 정한다. 
2. 캐릭터의 바로 왼쪽 방향에 가보지 않은 칸이 존재한다면, 왼쪽 방향으로 회전한 다음 왼쪽으로 한칸 전진한다. 왼쪽으로 가보지 않은 칸이 없다면 왼쪽방향으로 회전만 수행하고 1단계로 돌아간다.
3. 만약 네 방향 모두 이미 가본칸이거나 바다로 되어있는 칸인 경우 바라보는 방향을 유지한 채로 한칸 뒤로 가고 1단계로 돌아간다. 단, 이때 뒤쪽 방향이 바다인 칸이라 뒤로 못 갈 경우 움직임을 멈춘다.   
   
해당 문제와 같은 경우에는 미리 함수를 만들고 이동패턴을 만들어놓는것이 수월하다.   
1번의 왼쪽으로 회전한다의 경우를 미리 함수로 만들어 필요할때마다 호출하고,   
북, 동, 남, 서 에 따른 x,y의 이동 거리를 dx,dy 배열로 만들어 호출해준다.   
이처럼 코드를 작성하면, 반복문을 이용하여 모든 방향을 차례대로 확인할 수 있다는 점에서 유용하다.   
코드에 관한 더 자세한 설명은 해당 .swift에 주석으로 달아놓았다.   
   
위와 같은 메뉴얼로 이동시킨 후 캐릭터가 방문한 칸의 수를 출력하는 프로그램을 만드시오.   
(0 : 북쪽, 1 : 동쪽, 2: 남쪽, 3: 서쪽)   
(0 : 육지, 1 : 바다)   
   
전형적인 시물레이션 문제이다. 삼전 공채 코테에서 자주 출제되는 대표적인 유형이기도 하다.   
별도의 알고리즘이 필요하다기 보다는 요구하는 내용을 오류 없이 성실하게 구현하기만 한다면 풀 수 있는 문제라는 특징이 있다.   
다만 문제가 길어 바르게 이해하고 코드로 옮기는 과정이 간단하지 않다.   
따라서 반복적인 숙달이 필요하다.   
'방향을 설정해서 이동하는 문제 유형에는 dx, dy라는 별도의 리스트를 만들어 방향을 정하는 것이 효과적이다'   
