# 꼭 필요한 자료구조 기초
'탐색' 이란 많은 양의 데이터 중에서 원하느 데이터를 찾는 과정을 의미한다.   
대표적인 탐색 알고리즘으로 DFS와 BFS를 꼽을 수 있는데, 이 두 알고리즘의 원리를 제대로 이해해야 코테의 탐색문제를 풀 수 있다.   
DFS와 BFS를 이해하려면 스택과 큐에 대한 이해가 전제되어야 하므로 간단하게 정리하고 넘어가겠다.   
'자료구조'란 데이터를 표현하고 관리하고 처리하기 위한 구조를 의미한다.   
그 중 스택과 큐는 두 핵심적인 함수로 구성된다.   
- 삽입(Push)
- 삭제(Pop)
물론 실사용할때에는 오버플로와 언더플로를 고민해야한다.   
오버플로는 수용할 수 있는 데이터의 크기를 넘어섰을 때 발생하고, 언더플로는 아무런 저장데이터가 없는데 삭제연산을 수행했을 때 발생한다.   
   
⭐️ swift에는 파이썬과 같이 별도의 라이브러리가 없어 실제로 기능하는 함수를 따로 제작해줘야하는 불편함이 있다😂   
   
## 스택
박스 쌓기에 비유할 수 있다.   
선입출(FILO)(First In Last Out)구조로 가장 위에 쌓여있는 데이터가 우선 삭제되어야한다.   
```
import Foundation
func solution() {
    let n = Int(readLine()!)!
    var stack: [Int] = []
    for _ in 0..<n {
        let input = readLine()!.split(separator:" ").map{String($0)}
        switch input[0] {
        case "push":
            push(Int(input[1])!)
            break
        case "pop":
            print(pop())
            break
        case "size":
            print(size())
            break
        case "empty":
            print(empty())
            break
        case "top":
            print(top())
            break
        default:
            break
        }
    }


    func push(_ n : Int) {
        stack.append(n)
    }
    func pop() -> Int {
        if let pop = stack.popLast() {
            return pop
        } else {
            return -1
        }
    }
    func size() -> Int{
        return stack.count
    }
    func empty() -> Int{
        if stack.isEmpty == true {
            return 1
        } else {
            return 0
        }
    }
    func top() -> Int{
        if let pop = stack.last {
            return pop
        } else {
            return -1
        }
    }
}
solution()
```
위의 코드는 stack 구조를 함수화하여 만들어놓은 것이다.   
push, pop, size, empty, top기능을 사용할 수 있도록 하였다.   
   
## 큐
큐는 대기줄에 비유할 수 있다.   
선입선출(FIFO)(First In First Out) 구조로 먼저 줄은 선 사람이 먼저 나갈 수 있는 구조라고 볼 수 있다.   
   
⭐️ 물론 swift에는 파이썬과 같이 별도의 라이브러리가 없어 큐 또한 실제로 기능하는 함수를 따로 제작해줘야하는 불편함이 있다😂   
   
```
struct Queue<T> {
    private var queue: [T?] = []
    private var front: Int = 0
    
    public var frontValue: Int {
        return self.front
    }
    
    public var count: Int {
        return queue.count
    }
    
    public var isEmpty: Bool {
        return queue.isEmpty
    }
    
    public mutating func enqueue(_ element: T) {
        queue.append(element)
    }
    
    public mutating func dequeue() -> T? {
        guard front <= count, let element = queue[front] else { return nil }
        queue[front] = nil
        front += 1
        return element
    }
}
```
enque()를 통해 input, dequeue()를 통ㅇ해 output이 가능하다.   
   
## 재귀함수
DFS와 BFS를 이해하려면 재귀함수도 이해하고 있어야 한다.   
재귀함수는 자기 자신을 다시 호출하는 함수를 의미한다.   
팩토리얼과 같은 함수를 구현할때 자주 사용한다.   
```
import Foundation
func solution() {
    let input = Int(readLine()!)!

    func factorial(_ n : Int) -> Int{
        if n <= 1 {
            return 1
        } else {
            return n * factorial(n-1)
        }
    }
    
    print(factorial(input))
}
solution()
```
물론 for문을 통해 반복문으로 문제를 해결할 수도 있다.   
하지만 점화식을 그대로 소스코드를 옮겨놓는 방식이 훨씬 간결하다고 볼 수 있다.   
해당 개념은 다이나믹 프로그래밍으로도 이어지기 때문에 중요하다.   
   
## 탐색 알고리즘 DFS/BFS
### DFS(깊이 우선 탐색)
DFS(Depth-First Search) 깊이 우선 탐색이라고도 부름, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.   
그래프에서 서로 연결되어 있지 않은 노드끼리는 무한의 비용이라고 작성한다.   
DFS알고리즘은 특정한 경로를 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로를 탐색하는 알고리즘이다.   
1. 탐색 시작 노드를 스택에 삽입하고 방문처리를 한다.   
2. 스택의 최상단 노드에 방문하지 않은 인접노드가 있으면 그 인접노드를 스택에 넣고 방문 처리를한다. 방문하지 않은 인접노드가 없으면 스택에서 최상단 노드를 꺼낸다.   
3. 2번의 과정을 더이상 수행할 수 없을 때 까지 반복한다.   
   
<img width="567" alt="스크린샷 2023-05-12 오후 4 32 43" src="https://github.com/ww5702/Coding_Test/assets/60501045/02f1c474-4a26-44fb-b0c2-552360aad838">   
   
위의 그림에서 노드 1을 시작으로 설정하여 탐색을 진행한다면 과정은 다음과 같다.   
단순하게 가장 깊숙이 위치하는 노드에 닿을때까지 탐색을 하면 된다.   
또한 일반적으로 인접한 노드 중에서 방문하지 않은 노드가 여러 개 있으면 번호가 낮은 순서부터 처리한다.   
***
1 -> 방문하지 않은 노드 2, 3, 8이 있다 그중 가장 작은 노드 2를 스택에 넣고 방문처리한다.   
1, 2 ->스택의 최상단 노드인 2에는 방문하지 않은 인접 노드 7이 있다.   
1, 2, 7 -> 스택의 최상단 노드인 7에는 방문하지 않은 노드가 8과 6이 있다. 작은 수인 6 삽입   
1, 2, 7, 6 -> 스택의 최상단 노드인 6에는 더이상 노드가 없다 6을 삭제   
1, 2, 7 -> 스택의 최상단 노드인 7에는 방문하지 않은 노드 8이 있다. 8 삽입   
1, 2, 7, 8 -> 스택의 최상단 노드인 8에는 더이상 인접노드가 없다 8 삭제
1, 2, 7 -> 스택의 최상단 노드인 7에는 더이상 방문하지 않은 인접노드가 없다 7 삭제   
1, 2 -> 위와 동일하게 2삭제
1 -> 스택의 최상단 노드인 1의 방문하지 않은 노드인 3 삽입
1, 3 -> 스택의 최상단 노드인 3에는 4와 5가 있으므로 작은수인 4 삽입   
1, 3, 4 -> 스택의 최상단 노드인 4에는 인접노드가 없으므로 4 삭제   
1, 3 -> 스택의 최상단 노드인 3에는 아직 안간 노드 5가 있다.   
1, 3, 5 -> 이제 전부 방문했으므로 하나씩 빼준다.   
***
결과적으로 노드의 탐색 순서는   
1 - 2 - 7 - 6 - 8 - 3 - 4 - 5 가 된다.   
DFS는 스택을 이용하는 알고리즘이기 때문에 재귀함수를 이용했을 때 간결하게 구현할 수 있다.   
   
방문했는지를 파악하기 위한 bool로 이루어진 visited 1차원배열과   
각 노드가 연결된 정보를 리스트 자료형으로 표현한 2차원 리스트 graph를 통해   
재귀함수를 이용해 구현 할 수 있다.   
   
   
### BFS(너비 우선 탐색)
BFS(Breadth First Search) 알고리즘은 '너비 우선 탐색'이라는 의미를 가진다.   
쉽게 말해 가까운 노드부터 탐색하는 알고리즘이다.   
DFS는 최대한 멀리있는 노드부터 우선으로 탐색하는 방식으로 동작한다고 했는데 BFS는 그 반대이다.   
BFS의 구현은 선입선출 방식인 큐 자료구조를 이용하는 것이 정석이다.   
인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성한다면 자연스럽게 먼저 들어온 것이 먼저 나가게 되어,   
가까운 노드부터 탐색을 진행하게 된다.   
1. 탐색 시작 노드를 큐에 삽입하고 방문 처리한다.   
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리 한다.   
3. 2번의 과정을 더 이상 수행할 수 없을때 까지 반복한다.   
   
<img width="567" alt="스크린샷 2023-05-12 오후 4 32 43" src="https://github.com/ww5702/Coding_Test/assets/60501045/02f1c474-4a26-44fb-b0c2-552360aad838">   
   
위의 그림에서 노드1을 시작으로 탐색을 진행한다면 과정은 다음과 같아.   
숫자가 작은 노드부터 큐에 삽입한다고 가정한다.   
***
1 -> 시작 노드 1을 삽입하고 방문 처리 한다.   
2,3,8 -> 1을 꺼내고, 방문하지 않은 인접 노드 2,3,8을 전부 큐에 삽입하고 방문처리 한다.   
3,8,7 -> 2를 꺼내고 방문하지 않은 2의 인접노드 7을 삽입하고 방문처리한다.   
8,7,4,5 -> 3을 꺼내고 방문하지 않은 3의 인접노드 4,5를 삽입하고 방문처리한다.   
7,4,5 -> 8을 꺼내고 방문하지 않은 노드가 없으므로 무시한다.   
4,5,6 -> 7을 꺼내고 방문하지 않은 노드 6을 삽입하고 방문처리한다.   
5,6 -> 4를 꺼낸다.
6 -> 5를 꺼낸다.   
***
결과적으로 노드의 탐색 순서는   
1 - 2 - 3 - 8 - 7 - 4 - 5 - 6 가 된다.   
BFS(너비 우선 탐색 알고리즘)은 큐 자료구조에 기초한다는 점에서 구현이 간단하다.   
deque 라이브러리를 사용한다는 것이 좋으며 탐색을 수행함에 있어서 O(N)의 시간이 소요된다.   
일반적인 경우 수행시간은 DFS보다 좋은 편이라고만 추가적으로 기억하자.   
   
Queue를 직접 코드로 구현하고,   
방문했는지를 파악하기 위한 bool로 이루어진 visited 1차원배열과   
각 노드가 연결된 정보를 리스트 자료형으로 표현한 2차원 리스트 graph를 통해   
enqueue, dequeue를 적절히 섞어 bfs를 구현한다.   

## 음료수 얼려 먹기
N x M 크기의 얼음 틀이 있다.   
구멍이 뚫려있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시한다.   
구멍이 뚫려있는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다.   
얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하시오.   
   
이 문제는 DFS로 해결할 수 있다.   
먼저 주어진 2차원 배열을 입력받은 뒤, 상태가 0이라면 1로 바꾸는 방문표시를, 그 후 상하좌우로 좌표를 이동시켜   
방문한적이 있는지 없는지 확인한다. + 범위를 벗어났는지도 같이 확인   
0이라면 방문한적이 없을테니 그 상태에서 해당 좌표를 1로 또 바꿔주고 또 다시 상하좌우로 이동   
위의 과정을 반복하여 모두 1로 바꾸는 과정이 끝난다면 true를 return 해주고 count를 +1해준다.   
2중 반복문을 사용하여 모든 좌표를 탐색한다면 정답을 알아낼 수 있다.   
   
## 미로 탈출
N x N 크기의 직사각형 형태의 미로에 갇혀 있다.   
미로에는 여러 마리의 괴물이 있어 이를 피해 탈출해야 한다.   
사용자의 위치는 (1,1)이고, 미로의 출구는 (N,M)의 위치에 존재하며 한번에 한칸 씩 이동할 수 있다.   
이때 괴물이 있는 부분은 0, 없는 부분은 1이다.   
미로는 반드시 탈출 할 수 있는 형태로 제시된다.   
이때 동빈이가 탈출하기 위해 움직여야 하는 최소 칸의 개수를 구하시오.   
   
이 문제는 BFS로 효과적으로 해결 할 수 있다.   
BFS는 시작 지점에서 가까운 노드부터 차례대로 그래프의 모든 노드를 탐색하기 때문이다.   
따라서 (1,1)부터 BFS를 수행하여 모든 노드의 값을 거리 정보로 넣으면 된다.   
상하좌우의 이동값을 dx, dy 배열로 미리 지정한다음,   
상하좌우로 이동했을때 경로를 벗어나지않았거나 괴물이 존재하지않는다면 지금까지 왔던 거리의 +1을 해준다.   
