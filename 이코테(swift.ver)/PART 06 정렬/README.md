연속된 데이터를 기준에 따라서 정렬하기 위한 알고리즘   
# 기준에 따라 데이터를 정렬
'정렬'이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것을 말한다.   
오름차순이나 내림차순 등 대부분 어떤 식으로든 정렬해서 사용하는 경우가 많기에 정렬 알고리즘은 가장 많이 사용되는 알고리즘 중 하나이다.   
정렬을 배우면 다음 장에서 배울 '이진 탐색'이 가능해진다.   
우리는 여기서 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬을 배울 것이다.   
   
7 5 9 0 3 1 6 2 4 8   
우리는 위의 숫자를 오름차순으로 정렬하는 예제를 계속해서 사용할 것이다.   
   
## 선택 정렬
7 5 9 0 3 1 6 2 4 8   
이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 
그 다음 작은 데이터를 선택해 두번째 데이터와 바꾸는 과정을 반복하는 것이 선택 정렬이다.   
즉 n - 1 번 반복하면 정렬의 완료되는 구조인 것이다.   
```
func selection_sort() {
        var arr = [7,5,9,0,3,1,6,2,4,8]
        for i in 0..<arr.count {
            var min = arr[i]
            var minIndex = i
            for j in i+1..<arr.count {
                if min > arr[j] {
                    min = arr[j]
                    minIndex = j
                }
            }
            arr.swapAt(i, minIndex)
            print(arr)
        }
    }
selection_sort()
```
위 소스 코드와 같이 min과 minIndex를 통해 제일 낮은 수를 찾아 현재 arr[i]와 바꿔주는 방식이다.   
그렇다면 선택 정렬의 시간 복잡도는 어떨까?   
N - 1 번 만큼 가장 작은 수를 찾아 맨 앞으로 보내야 한다.   
또한 매번 비교 연산을 수행하니 N + (N-1) + (N-2) ... 으로 볼 수 있다.   
이는 (N^2 + N) / 2로 표현할 수 있는데 O(N^2)로 표현할 수 있다.   
즉 10,000개 이상이면 선택 정렬의 효율이 매우 안좋아진다는 것을 의미한다.   
   
## 삽입 정렬
데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하는 방법   
선택 정렬에 비해 구현 난이도가 높은 편이지만, 실행 시간 측면에서는 더 효율적인 알고리즘이다.   
삽입 정렬은 필요할 때만 위치를 바꾸므로 데이터가 거의 정렬되어 있을 때 효율적이다.   
삽입 정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.   
정렬되어 있는 리스트에서 적절한 위치를 찾은 뒤에 그 위치에 삽입된다는 점이 특징이다.   
7 5 9 0 3 1 6 2 4 8   
삽입 정렬은 2번째 데이터부터 시작한다. 첫번쨰 데이터는 그 자체로 정렬되어 있다고 생각하기 때문이다.   
두 번째 데이터인 5가 어떤 위치로 들어갈지 생각하는데 오름차순으로 정렬하므로 왼쪽으로 삽입된다.   
5 7   
그 다음 9를 위치시킨다.   
5 7 9   
0을 위치시킨다.   
0 5 7 9   
0 3 5 7 9   
-> 위와 같은 방식에서 삽입정렬이 더 효율적인 이유를 알 수있다.   
3은 왼쪽으로 한칸씩 가다가 0을 만나면 이동을 멈추게 된다.   
즉, 이미 정렬이 되어있는 리스트이기에 더이상 계산을 할 필요가 없다는 뜻이다.   
즉, 계산의 횟수를 줄여준다.   
이렇게 본인의 위치를 찾아가 N - 1번 반복하게 되면 데이터가 정렬되는 것을 확인할 수 있다.   
```
    func insertion_sort() {
        var arr = [7,5,9,0,3,1,6,2,4,8]
        for i in 1..<arr.count {
            // i에서부터 1까지 감소하며 확인
            for j in stride(from: i, to: 0, by: -1) {
                if arr[j] < arr[j-1] {
                    arr.swapAt(j, j-1)
                }
            }
            print(arr)
        }
    }
    insertion_sort()
```
i에서부터 역으로 -1씩 하며 0까지 확인하면서 arr[j]가 더 작으면 계속해서 바꿔주는 방식이다.   
그렇다면 삽입정렬의 시간복잡도는 어떻게 될까?   
물론 2중 반복문을 사용하므로 O(N^2)가 된다.   
하지만 데이터가 거의 정렬되어있다면 매우 빠르게 작동한다는 점이 특징이다.   
최선의 경우 O(N)까지 가능하다.   
다음으로 배울 퀵 정렬보다 만약 정렬되어있는 상태라면 더 효율이 좋다고 할 수 있다.   
