연속된 데이터를 기준에 따라서 정렬하기 위한 알고리즘   
# 기준에 따라 데이터를 정렬
'정렬'이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것을 말한다.   
오름차순이나 내림차순 등 대부분 어떤 식으로든 정렬해서 사용하는 경우가 많기에 정렬 알고리즘은 가장 많이 사용되는 알고리즘 중 하나이다.   
정렬을 배우면 다음 장에서 배울 '이진 탐색'이 가능해진다.   
우리는 여기서 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬을 배울 것이다.   
   
7 5 9 0 3 1 6 2 4 8   
우리는 위의 숫자를 오름차순으로 정렬하는 예제를 계속해서 사용할 것이다.   
   
## 선택 정렬
7 5 9 0 3 1 6 2 4 8   
이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 
그 다음 작은 데이터를 선택해 두번째 데이터와 바꾸는 과정을 반복하는 것이 선택 정렬이다.   
즉 n - 1 번 반복하면 정렬의 완료되는 구조인 것이다.   
```
func selection_sort() {
        var arr = [7,5,9,0,3,1,6,2,4,8]
        for i in 0..<arr.count {
            var min = arr[i]
            var minIndex = i
            for j in i+1..<arr.count {
                if min > arr[j] {
                    min = arr[j]
                    minIndex = j
                }
            }
            arr.swapAt(i, minIndex)
            print(arr)
        }
    }
selection_sort()
```
위 소스 코드와 같이 min과 minIndex를 통해 제일 낮은 수를 찾아 현재 arr[i]와 바꿔주는 방식이다.   
그렇다면 선택 정렬의 시간 복잡도는 어떨까?   
N - 1 번 만큼 가장 작은 수를 찾아 맨 앞으로 보내야 한다.   
또한 매번 비교 연산을 수행하니 N + (N-1) + (N-2) ... 으로 볼 수 있다.   
이는 (N^2 + N) / 2로 표현할 수 있는데 O(N^2)로 표현할 수 있다.   
즉 10,000개 이상이면 선택 정렬의 효율이 매우 안좋아진다는 것을 의미한다.   
   
## 삽입 정렬
데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하는 방법   
선택 정렬에 비해 구현 난이도가 높은 편이지만, 실행 시간 측면에서는 더 효율적인 알고리즘이다.   
삽입 정렬은 필요할 때만 위치를 바꾸므로 데이터가 거의 정렬되어 있을 때 효율적이다.   
삽입 정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다.   
정렬되어 있는 리스트에서 적절한 위치를 찾은 뒤에 그 위치에 삽입된다는 점이 특징이다.   
7 5 9 0 3 1 6 2 4 8   
삽입 정렬은 2번째 데이터부터 시작한다. 첫번쨰 데이터는 그 자체로 정렬되어 있다고 생각하기 때문이다.   
두 번째 데이터인 5가 어떤 위치로 들어갈지 생각하는데 오름차순으로 정렬하므로 왼쪽으로 삽입된다.   
5 7   
그 다음 9를 위치시킨다.   
5 7 9   
0을 위치시킨다.   
0 5 7 9   
0 3 5 7 9   
-> 위와 같은 방식에서 삽입정렬이 더 효율적인 이유를 알 수있다.   
3은 왼쪽으로 한칸씩 가다가 0을 만나면 이동을 멈추게 된다.   
즉, 이미 정렬이 되어있는 리스트이기에 더이상 계산을 할 필요가 없다는 뜻이다.   
즉, 계산의 횟수를 줄여준다.   
이렇게 본인의 위치를 찾아가 N - 1번 반복하게 되면 데이터가 정렬되는 것을 확인할 수 있다.   
```
    func insertion_sort() {
        var arr = [7,5,9,0,3,1,6,2,4,8]
        for i in 1..<arr.count {
            // i에서부터 1까지 감소하며 확인
            for j in stride(from: i, to: 0, by: -1) {
                if arr[j] < arr[j-1] {
                    arr.swapAt(j, j-1)
                }
            }
            print(arr)
        }
    }
    insertion_sort()
```
i에서부터 역으로 -1씩 하며 0까지 확인하면서 arr[j]가 더 작으면 계속해서 바꿔주는 방식이다.   
그렇다면 삽입정렬의 시간복잡도는 어떻게 될까?   
물론 2중 반복문을 사용하므로 O(N^2)가 된다.   
하지만 데이터가 거의 정렬되어있다면 매우 빠르게 작동한다는 점이 특징이다.   
최선의 경우 O(N)까지 가능하다.   
다음으로 배울 퀵 정렬보다 만약 정렬되어있는 상태라면 더 효율이 좋다고 할 수 있다.   
   
## 퀵 정렬
퀵 정렬은 병합 알고리즘과 버금가는 가장 많이 사용되는 알고리즘이다.   
퀵 정렬의 기본 공식은 '기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸자' 이다.   
퀵 정렬에는 피벗이 사용된다.   
큰 숫자와 작은 숫자를 교환할 때, 교환의 기준을 바로 피벗이라고 표현한다.   
리스트에서 첫번째 데이터를 피벗으로 정했다면   
왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터는 피벗보다 작은 데이터를 찾는다.   
그 다음 큰 데이터와 작은 데이터를 교환해준다.   
5 7 9 0 3 1 6 2 4 8   
첫 번째 데이터를 피벗으로 설정하므로 '5'이다.   
5보다 큰 숫자를 선택해야 하므로 7, 오른쪽에서부터는 5보다 작은 숫자를 찾아야 하니 4가 된다.   
이제 두 데이터를 서로 변경한다.   
5 4 9 0 3 1 6 2 7 8   
그 다음 큰 숫자는 9, 작은 숫자는 2   
5 4 2 0 3 1 6 9 7 8   
그 다음 숫자는 6, 작은 숫자는 1이 되는데 서로 위치가 크로스 되어있음을 확인할 수 있다.   
그럴 경우 작은 데이터와 피벗의 위치를 변경하여 분할을 수행한다.   
1 4 2 0 3 5 6 9 7 8   
이렇게 바뀐 후 살펴본다면 5를 기준으로 왼쪽은 5보다 전부 작은 수, 오른쪽은 전부 큰 수로 나눠지게 된다.   
이제 왼쪽과 오른쪽을 나눠 서로 각각 정렬을 해준다.   
```
func solution() {
    var arr = [5,7,9,0,3,1,6,2,4,8]
    
    func quick_sort(_ start: Int, _ end: Int) {
        if start >= end { return } // 만약 원소가 1개인 경우 종료
        
        var pivot = start // 첫 피봇은 첫번째 원소
        var left = start + 1
        var right = end
        while left <= right {
            // 피벗보다 큰 데이터를 찾을때까지 반복
            // left가 end보다 작고, arr[left]가 설정한 피봇의 수보다 작을경우 계속 반복
            while left <= end && arr[left] <= arr[pivot] {
                left += 1
            }
            // 피벗보다 작은 데이터를 찾을때까지 반복
            // right가 start보다 크고, arr[right]가 설정한 피봇의 숫자보다 클경우 계속 반복
            while right > start && arr[right] >= arr[pivot] {
                right -= 1
            }
            // 만약 숫자가 서로 엇갈렸다면 작은 데이터와 피봇을 교체
            if left > right {
                arr.swapAt(right, pivot)
                print(arr)
            } else {
                // 엇갈리지 않았다면 작은데이터와 큰 데이터를 교체
                arr.swapAt(left, right)
                print(arr)
            }
        }
        // 한차례 정렬이 끝났다면 왼쪽 부분과 오른쪽 부분으로 다시 소팅
        quick_sort(start, right - 1)
        quick_sort(right + 1, end)
    }
    quick_sort(0, arr.count-1)
    print(arr)
    
}
```
이제 퀵 정렬의 시간복잡도에 대해 알아보자.   
퀵 정렬의 평균 시간 복잡도는 O(NlogN)이다.   
하지만 최악의 경우 시간복잡도가 O(N^2)가 된다.   

## 계수 정렬   

계수 정렬은 특정한 조건이 부합할때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.   
모든 데이터가 양의 정수라고 가정했을때 계수 정렬은 최악의 경우에도 수행시간 O(N+K)를 보장한다.   
하지만 계수정렬은 '데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을때'만 사용이 가능하다.   
일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다.   
계수 정렬은 먼저 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트를 생성한다.   
초기 단계 : 7 5 9 0 3 1 6 2 9 1 4 8 0 5 2   
라고 가정했을 때 9보다 큰 10인 리스트를 선언하면 된다.   
0 1 2 3 4 5 6 7 8 9   
0 0 0 0 0 0 0 0 0 0   
---   
0 1 2 3 4 5 6 7 8 9   
0 0 0 0 0 0 0 1 0 0   
---   
0 1 2 3 4 5 6 7 8 9   
0 0 0 0 0 1 0 1 0 0   
---   
위와 같이 몇 번 등장했는지 그 횟수가 기록된다.   
0 1 2 3 4 5 6 7 8 9   
2 2 2 1 1 2 1 1 1 2   
그리고 출력을 작은 숫자부터 해주는 것이다.   
0 0 1 1 2 2 3 4 5 5 6 7 8 9 9   
```
var arr = [7,5,9,0,3,1,6,2,9,1,4,8,0,5,2]
    var count = Array(repeating: 0, count: arr.max()!+1)
    for i in arr {
        count[i] += 1
    }
    for i in 0..<count.count {
        for _ in 0..<count[i] {
            print(i, terminator: " ")
        }
    }
```
코드로 구현하기는 간단하다.   
기존 배열보다 +1로 배열을 만들어주고 0으로 초기화, 그리고 반복해서 나오는 횟수만큼 += 1 해준다.   
그리고 해당 배열을 나열해주기만 하면 끝   
시간 복잡도는 앞서 말했다시피 O(N + K)이다.   
데이터의 범위만 한정되어 있다면 효과적으로 사용할 수 있으며 항상 빠르게 동작한다.   
하지만 데이터가 0, 999,999, 단 2개만 존재한다할지라도 계수정렬은 1,000,000개의 배열을 준비해야한다는 단점이 존재한다.   
따라서 항상 사용할 수 있는 알고리즘이 아니며, 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합하다.   
예를 들어 100점을 맞은 학생이 여러명일 수 있기 때문에 해당 경우에 효과적이다.   
하지만 일반적으로 퀵 정렬이 빠르게 동작하기 때문에 데이터의 특성을 파악하기 어렵다면 퀵 정렬을 이용하는 것이 유리하다.   
   
우리는 나가아 정렬라이브러리로 풀수있는 문제(sort,sorted) / 선택,삽입,퀵 정렬의 원리를 알야아 푸는 문제 / 계수 정렬등 개선을 걸쳐야 풀 수 있는 문제   
3가지 유형에 대해 다뤄볼 것이다.   
