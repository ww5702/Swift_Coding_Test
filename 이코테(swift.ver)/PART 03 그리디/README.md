# 당장 좋은 것만 선택하는 그리디
그리디 알고리즘은 단순하지만 강력한 문제 해결 방법이다.   
이 알고리즘 유형은 국내 알고리즘 교재에서 탐욕법으로 소개된다.   
이름에서 알 수 있듯이 어떠한 문제가 있을때 단순하게 탐욕적으로 문제를 푸는 알고리즘이다.   
여기서 탐욕적이라는 것은 '현재 상황에서 당장 좋은 것만 고르는 방법'을 의미한다.   
즉, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다는 뜻이다.   
   
앞으로 시험에서 만나게 될 그리디 알고리즘 유형은 사전에 외우지 않아도 풀 수 있을 가능성이 높은 문제 유형이다.   
반면 정렬, 최단 경로 등의 알고리즘 유형은 그 알고리즘의 사용 방법을 정확히 알고 있어야만 하는 경우가 많다.   
   
그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로   
문제에서 가장 큰 순서대로 / 가장 작은 순서대로 와 같은 기준을 알게 모르게 제시해준다.   
   
이를 대표하는 문제로는 '거스름돈'문제를 들 수 있다.      
'가장 큰 화폐 단위부터' 돈을 거슬러 주는 방법은 최소의 개수로 거스름돈을 줄 수가 있다.   
```
import Foundation
func solution() {
    var n = 1260
    var count = 0
    var coin_arr = [500,100,50,10]
    for coin in coin_arr {
        count += (n/coin)
        n %= coin
        print(n)
    }
    print(count)
}
solution()
```
1260원의 돈을 최소의 동전으로 나누어주는 알고리즘이다.   
코드를 보면 화폐의 종류만큼 반복을 수행해야 한다(500원으로 for문에 끝나면 100원으로)   
따라서 위 코드의 시간 복잡도는 O(K)라고 볼 수 있다.   
즉, 1260원은 시간복잡도에 전혀 관계가 없다는 것을 알 수 있다.   

## 그리디 알고리즘의 정당성
그리디 알고리즘을 모든 알고리즘 문제에 적용할 수는 없다.   
대부분의 문제는 그리디 알고리즘을 적용했을 때 '최적의 해'를 찾을 수 없을 가능성이 크다.   
하지만 큰 틀로 봤을 때 '탐욕적'으로 접근했을 때 답을 찾을 보장이 있을 때에는 효과적이고 매우 직관적이다.   
   
그리디 알고리즘으로 답을 찾았을 때에는 해당 답이 정당한지 검토해야 한다.   
만약 화폐 단위가 500, 400, 100이고 거슬러줘야 하는 돈이 800원이라면   
그리디 알고리즘으로는 500, 100, 100, 100으로 해답이 나오지만,   
가장 최적의 해는 400, 400으로 틀린 정답이 된다.   
해당 문제는 그리디 알고리즘이 아닌 '다이나믹 프로그래밍'으로 해결 할 수 있다.   

## 큰 수의 법칙
main1로 기본적인 해결방안을 제시 할 수있다.   
하지만 100억 이상처럼 커진다면 시간 초과 판정을 받을 것이다.   
따라서 문제를 풀려면 반복되는 수열에 대해서 파악해야 한다.   
[6,6,6,5]가 반복되어 더해지게 되는데, 수열의 길이는 제한으로 가져온 k = 3 + 1의 길이로 정해진다.   
따라서 M = 8을 k+1로 나눈 몫 만큼 수열이 반복된다.   
이때 딱 나눠지지 않을 경우도 생각해줘야한다.   
k+1로 m을 나누고 남은 나머지 만큼 큰 수를 더해주면 효과적인 알고리즘이라고 할 수 있다.   
