# 당장 좋은 것만 선택하는 그리디
그리디 알고리즘은 단순하지만 강력한 문제 해결 방법이다.   
이 알고리즘 유형은 국내 알고리즘 교재에서 탐욕법으로 소개된다.   
이름에서 알 수 있듯이 어떠한 문제가 있을때 단순하게 탐욕적으로 문제를 푸는 알고리즘이다.   
여기서 탐욕적이라는 것은 '현재 상황에서 당장 좋은 것만 고르는 방법'을 의미한다.   
즉, 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않는다는 뜻이다.   
   
앞으로 시험에서 만나게 될 그리디 알고리즘 유형은 사전에 외우지 않아도 풀 수 있을 가능성이 높은 문제 유형이다.   
반면 정렬, 최단 경로 등의 알고리즘 유형은 그 알고리즘의 사용 방법을 정확히 알고 있어야만 하는 경우가 많다.   
   
그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로   
문제에서 가장 큰 순서대로 / 가장 작은 순서대로 와 같은 기준을 알게 모르게 제시해준다.   
   
이를 대표하는 문제로는 '거스름돈'문제를 들 수 있다.      
'가장 큰 화폐 단위부터' 돈을 거슬러 주는 방법은 최소의 개수로 거스름돈을 줄 수가 있다.   
```
import Foundation
func solution() {
    var n = 1260
    var count = 0
    var coin_arr = [500,100,50,10]
    for coin in coin_arr {
        count += (n/coin)
        n %= coin
        print(n)
    }
    print(count)
}
solution()
```
1260원의 돈을 최소의 동전으로 나누어주는 알고리즘이다.   
코드를 보면 화폐의 종류만큼 반복을 수행해야 한다(500원으로 for문에 끝나면 100원으로)   
따라서 위 코드의 시간 복잡도는 O(K)라고 볼 수 있다.   
즉, 1260원은 시간복잡도에 전혀 관계가 없다는 것을 알 수 있다.   

## 그리디 알고리즘의 정당성
그리디 알고리즘을 모든 알고리즘 문제에 적용할 수는 없다.   
대부분의 문제는 그리디 알고리즘을 적용했을 때 '최적의 해'를 찾을 수 없을 가능성이 크다.   
하지만 큰 틀로 봤을 때 '탐욕적'으로 접근했을 때 답을 찾을 보장이 있을 때에는 효과적이고 매우 직관적이다.   
   
그리디 알고리즘으로 답을 찾았을 때에는 해당 답이 정당한지 검토해야 한다.   
만약 화폐 단위가 500, 400, 100이고 거슬러줘야 하는 돈이 800원이라면   
그리디 알고리즘으로는 500, 100, 100, 100으로 해답이 나오지만,   
가장 최적의 해는 400, 400으로 틀린 정답이 된다.   
해당 문제는 그리디 알고리즘이 아닌 '다이나믹 프로그래밍'으로 해결 할 수 있다.   

## 큰 수의 법칙
main1로 기본적인 해결방안을 제시 할 수있다.   
하지만 100억 이상처럼 커진다면 시간 초과 판정을 받을 것이다.   
따라서 문제를 풀려면 반복되는 수열에 대해서 파악해야 한다.   
main2로 위의 문제를 해결할 수 있다.   
[6,6,6,5]가 반복되어 더해지게 되는데, 수열의 길이는 제한으로 가져온 k = 3 + 1의 길이로 정해진다.   
따라서 M = 8을 k+1로 나눈 몫 만큼 수열이 반복된다.   
이때 딱 나눠지지 않을 경우도 생각해줘야한다.   
k+1로 m을 나누고 남은 나머지 만큼 큰 수를 더해주면 효과적인 알고리즘이라고 할 수 있다.   
   
## 숫자 카드 게임
여러 개의 숫자 카드 중에서 가장 높은 숫자가 쓰인 카드 한장을 뽑는 게임이다.   
룰은 다음과 같다.   
1. N X M 의 형태로 놓여저 있다.   
2. 먼저 뽑고자 하는 카드가 포함되어있는 행을 선택한다.   
3. 선택된 행에서 가장 숫자가 낮은 카드를 뽑아야 한다.   
4. 따라서 처음 행을 선택할 때, 이후에 해당 행에서 가장 낮은 카드를 뽑을 것을 고려하여 최종적으로 가장 높은 숫자를 뽑을 수 있도록 전략을 짜야한다.   
   
각 행마다 가장 작은 수를 찾은 뒤에 그 수 중에서 가장 큰 수를 찾는 방법으로 쉽게 풀 수 있다.   
지문을 이해하는데 오래 걸릴 뿐이지 풀이 방법은 이중반복문 구조로 해결할 수 있다.   
물론 입력으로 들어오는 수가 10,000 이하이므로 단순해지는것이다.   
   
## 1이 될 때 까지
어떠한 수 N이 1이 될 때까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다.   
1. N에서 1을 뺀다.   
2. N을 K로 나눈다.   
N이 17, k가 4라고 가정하고 1번의 과정을 한번 수행하면 N은 16, 그 후 2번의 과정을 두번 수행하면 1이 된다.   
총 3번의 횟수로 1을 만들 수 있고, 해당 횟수가 최소 횟수이다.   
   
당연히 1로 빼는것보다는 K로 나누는 것이 숫자를 크게 줄일 수 있다.   
따라서 N이 K의 배수가 될때까지 1씩 빼다가 배수일 때 K로 나누면 된다.   
N의 범위가 100억 이하의 수이면 main1로도 문제를 해결할 수 있지만, 100억 이사으이 수일때는   
N이 K의 배수가 되도록 효율적으로 한번에 빼는 방식으로 소스코드를 작성할 수 있다   
미리 N이라는 거대한 수 (100억이상)중에서 K의 배수들중 가장 가까운 배수를 미리 구하여 그 차이만큼 1을 뺀다는 공식으로 접근한다.-> main2.   
