특정 지점까지 가장 빠르게 도달하는 방법을 찾는 알고리즘   
# 가장 빠른 길 찾기
'최단 경로' 알고리즘은 말 그대로 가장 짧은 경로를 찾는 알고리즘이다.   
그래서 '길 찾기' 문제라고도 불린다.   
   
상황에 따라 효율적인 알고리즘이 다른데,   
'한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우'   
'모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우'   
와 같이 다양한 사례가 존재한다.   
최단 경로 문제의 경우 보통 그래프를 통해 표현하는데 각 지점은 그래프에서 '노드'로 표현되고, 지점간 연결된 도로는 '간선'으로 표현된다.   
코테에서는 최단 경로를 모두 출력하는 문제보다는 단순히 최단 거리를 출력하도록 요구하는 문제가 많이 출제된다.   
   
최단 거리 알고리즘은 '다익스트라 최단 경로 알고리즘' / '플로이드 워셜' / '벨만 포드 알고리즘' 이렇게 3개 이다.   
그 중 많이 등장하는 다익스트라, 플로이드 워셜 알고리즘 유형만 다룬다.   
이 두개만 이용해도 최단 경로 문제는 어렵지 않게 해결이 가능하다.   
앞서 배운 그리디 알고리즘과 다이나믹 프로그래밍 알고리즘이 최단 경로 알고리즘에 사용된다는 특징이 있다.   
   
## 다익스트라 최단 경로 알고리즘
그래프에서 여러 개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘이다.   
다익스트라 최단 경로 알고리즘은 '음의 간선'이 없을 떄 정상적으로 작동하는데 0보다 작은 값을 가지는 간선이 없어야 한다는 의미이다.   
기본적으로 다익스트라 알고리즘은 그리디 알고리즘으로 구분된다.   
매번 가장 비용이 적은 노드를 선택하는 과정을 반복하기 때문이다.   
과정은 다음과 같다.   
1. 출발 노드 설정   
2. 최단 거리 테이블을 초기화한다.   
3. 방문하지 않은 노드 중 최단 거리가 짧은 노드를 선택한다.   
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.   
5. 3,4 과정을 반복한다.   
각 노드에 대한 현재까지의 최단 거리 정보를 항상 1차원 리스트에 저장하며 리스트를 계속 갱신한다는 특징이 있다.   
나중에 현재 처리하고 있는 노드와 인접한 노드로 도달하는 더 짧은 경로를 찾으면 '더 짧은 경로가 있으므로 이 경로가 최단 경로야' 라고 판단하는 것이다.   
   
또한 구현하는 방법은 2가지 이다.   
   
1번. 구현하기 쉽지만 느리게 동작하는 코드   
2번. 구현하기 조금 더 까다롭지만 빠르게 동작하는 코드   
당연히 2번을 구현할 수 있을 떄 까지 연습해야 한다.   
   
<img width="430" alt="스크린샷 2023-05-25 오후 5 29 17" src="https://github.com/ww5702/Coding_Test/assets/60501045/b759a30a-9bc3-4a31-9f44-5570aa25f13a">   
   
다음과 같은 그래프가 있을 때 1번 노드가 다른 모든 노드로의 최단 거리를 계산해볼 것이다.   
우선 초기 상태에는 다른 노드로 가는 최단 거리를 '무한'으로 설정한다.   
헷갈리지 않기 위해 '987,654,321'으로도 가능하다.   
```
1 2 3 4 5 6   
0 무 무 무 무   
-----------   
이제 1번노드를 거쳐 다른 노드로 가는 비용을 계산한다.   
모든 간선을 하나씩 확인하면 된다.   
1 2 3 4 5 6   
0 2 5 1 - -   
-----------   
이후에는 가장 거리가 짧은 노드인 '4'를 선택해 다른 노드로 움직이는 경우를 계산한다.   
1 2 3 4 5 6
0 2 4 1 2 -   
4를 통과해 3으로 이동하는 거리가 4이고 1에서 바로 3으로 이동하는 거리가 5이다.   
더 적은 경로로 이동할 수 있기에 4로 갱신한다.   
또한 4를 통해 5로도 이동할 수 있기에 5도 2로 갱신한다.   
-----------   
이제는 2와 5중에 2를 선택하여 진행한다.   
1에서 2를 통과해 이동하는 경우를 계산하는 것이다.   
보통 거리가 같다면 더 작은 번호를 고른다.   
1 2 3 4 5 6   
0 2 4 1 2 -   
하지만 2를 통과해 이동했을때 경로가 더 단축되는 경우는 없기에   
그래프에 변동사항은 없다.   
-----------   
이제 5가 선택된다.   
1에서 4를 거쳐 5에서 시작되는 과정이다.   
1 2 3 4 5 6   
0 2 3 1 2 4   
3과 6의 경로가 갱신된다.   
-----------   
남은 경로 3, 6중 더 적은 3을 선택한다.   
1 4 5 3의 경로로 움직이는 과정이다.   
1 2 3 4 5 6   
0 2 3 1 2 4   
변동사항은 없다.   
-----------   
```
마지막 남은 6을 선택하여도 결과는 동일하다.   
따라서 1번노드로부터 출발했을때 각 노드별로 최단 경로로 도착하는 값은   
0 2 3 1 2 4 가 된다.   
   
이제 알고리즘을 실제 구현해보자.   
먼저 말했던 쉽게 구현하는 방법이다.   
O(V^2)의 시간복잡도를 가지는데 여기서 V는 노드의 개수를 말한다.   
```
import Foundation
func solution() {
    let input = readLine()!.split(separator: " ").map{Int($0)!}
    let (n,m) = (input[0],input[1])
    let start = Int(readLine()!)!
    let INF = 987654321
    var graph = Array(repeating: [(Int,Int)](), count: n+1)
    var distance = Array(repeating: INF, count: n+1)
    var visited = Array(repeating: false, count: n+1)
    for _ in 0..<m {
        let input = readLine()!.split(separator: " ").map{Int($0)!}
        let (a,b,c) = (input[0],input[1],input[2])
        graph[a].append((b,c))
    }
    print(graph)
    
    // 현재 distance에서 방문했던 적이 없었으면서 최단 거리인 노드는?
    func getSmallNode() -> Int {
        var min = INF
        var index = 0
        for i in 1..<n+1 {
            if distance[i] < min && !visited[i] {
                min = distance[i]
                index = i
            }
        }
        return index
    }
    
    func dijkstra(_ start: Int) {
        distance[start] = 0
        visited[start] = true
        
        for i in graph[start] {
            distance[i.0] = i.1
            // i가 1일때 2,3,4까지의 거리는 2,5,1로 입력한다는 뜻
        }
        print(distance)
        // 시작 노드를 제외한 전체 노드에 대해 최단 거리 계산
        for _ in 0..<n-1 {
            let now = getSmallNode()
            visited[now] = true
            print("현재 서있는 노드 = \(now)")
            for j in graph[now] {
                // 현재 서있는 노드까지의 거리 + 해당 노드에서 갈수있는 노드까지의 거리의 합
                // 그 거리의 합과 기존에 적혀있는 합과 비교했을때 더 작다면 더 빠르게 갈 수 있다는 뜻
                let cost = distance[now] + j.1
                if cost < distance[j.0] {
                    distance[j.0] = cost
                }
            }
        }
    }
    dijkstra(start)
    for i in 1..<n+1 {
        if i == INF {
            print("INFINITY")
        } else {
            print(distance[i])
        }
    }
}
solution()

```
복잡해 보이지만 주석과 함께 살펴본다면 그리 어렵지 않다는 것을 알 수 있다.   
앞서 말했듯이 복잡도는 O(V^2)이다. 노드의 갯수에 따라 매번 O(V)번씩 선형탐색해야하고,   
현재 노드와 연결된 노드를 매번 일일이 확인하기 떄문이다.   
따라서 5,000개 이하의 노드개수라면 이 코드로도 풀 수 있다.   
하지만 10,000개가 넘는 노드개수라면 '개선된 다익스트라 알고리즘'을 이용해야 한다.   
   
그렇다면 2번째 방법인 개선된 다익스트라 알고리즘을 구현해보자.   
개선된 알고리즘은 최악의 경우에도 시간복잡도 O(ElogV)를 보장하여 해결할 수 있다.   
V는 노드이 개수이고 E는 간선의 개수를 의미한다.   
개선된 알고리즘의 시간단축개념은 단순하다.   
위에서 풀이한 방법은 선형탐색으로 최단 거리가 짧은 노드를 찾았지만 최단 거리를 더욱 빠르게 찾는 형식으로 시간을 줄이는 것이다.   
여기서 힙(Heap) 자료구조를 사용한다.   
힙 자료구조는 특정 노드까지의 최단 거리에 대한 정보를 힙에 담아서 처리하므로   
출발 노드로부터 가장 거리가 짧은 노드를 더욱 빠르게 찾을 수 있다.   
이 과정에서 선형 시간이 아닌 로그 시간이 걸린다.   
따라서 먼저 힙에 대해 알아보자.   
   
### 힙
힙 자료구조는 우선순위 큐를 구현하기 위하여 사용하는 자료구조 중 하나이다.   
우선순위 큐는 '우선순위가 가장 높은 데이터를 가장 먼저 삭제한다는 점' 이 특징이다.   
따라서 여러 물건 데이터를 자료구조에 넣었다가 가치가 높은 물건 데이터붵 꺼내서 확인해야 하는 경우 효과적이다.  
```
대부struct PriorityQueue<T: Comparable> {
    private var heap = [T]()
    
    var isEmpty: Bool {
        return heap.isEmpty
    }
    
    var count: Int {
        return heap.count
    }
    
    mutating func enqueue(_ element: T) {
        heap.append(element)
        heapifyUp(heap.count - 1)
    }
    
    mutating func dequeue() -> T? {
        if heap.isEmpty {
            return nil
        }
        
        heap.swapAt(0, heap.count - 1)
        let element = heap.removeLast()
        heapifyDown(0)
        
        return element
    }
    
    private mutating func heapifyUp(_ index: Int) {
        var childIndex = index
        var parentIndex = (childIndex - 1) / 2
        
        while childIndex > 0 && heap[childIndex] < heap[parentIndex] {
            heap.swapAt(childIndex, parentIndex)
            childIndex = parentIndex
            parentIndex = (childIndex - 1) / 2
        }
    }
    
    private mutating func heapifyDown(_ index: Int) {
        let lastIndex = heap.count - 1
        var parentIndex = index
        
        while true {
            let leftChildIndex = parentIndex * 2 + 1
            let rightChildIndex = parentIndex * 2 + 2
            var minIndex = parentIndex
            
            if leftChildIndex <= lastIndex && heap[leftChildIndex] < heap[minIndex] {
                minIndex = leftChildIndex
            }
            
            if rightChildIndex <= lastIndex && heap[rightChildIndex] < heap[minIndex] {
                minIndex = rightChildIndex
            }
            
            if minIndex == parentIndex {
                break
            }
            
            heap.swapAt(parentIndex, minIndex)
            parentIndex = minIndex
        }
    }
}

var pq = PriorityQueue<Int>()
```
   
위와 같은 구조로 힙을 구현해 둘 수 있다.   
하지만 .sorted(by: { Bool }) 와 같은 방식으로 좀더 쉽고 직관적으로 구현이 가능하다.   
   
최소 힙을 이용하면 가장 값이 작은 원소가 추출이 되며, 최대 힙을 이용하면 가장 값이 큰 원소가 추출이 된다.   
다시 한번 위의 그래프를 우선순위 큐를 이용해 풀이해보자.   
   
<img width="430" alt="스크린샷 2023-05-25 오후 5 29 17" src="https://github.com/ww5702/Coding_Test/assets/60501045/b759a30a-9bc3-4a31-9f44-5570aa25f13a">   
   
```
역시 1번노드가 출발 노드인 경우다.   
1 2 3 4 5 6
0 - - - - -
우선순위 큐 / (거리:0 노드:1)
우선순위 큐에 1번 노드를 넣는다. 
이때 1번 노드로 가는 거리는 자기 자신까지 도달하는 거리이기에 0이다.   
튜플을 입력받으면 튜플의 첫 번쨰 원소를 기준으로 우선순위 큐를 구성한다.
따라서 거리 순으로 자동 정렬된다.
----------- 
우선순위 큐를 이용하기에 가장 짧은 원소가 최상위 원소로 위치해있다.   
따라서 우선순위 큐에서 노드를 꺼낸뒤 방문한 적이 있다면 무시하고, 방문한적이 없다면 사용하면 된다.
우선순위 큐에서 원소를 꺼낸다면 (0,1)이 나온다.
1 2 3 4 5 6
0 2 5 1 - -
우선순위 큐 / (거리:1 노드:4)(거리:2 노드:2)(거리:5 노드:3)
-> 자동으로 거리 순으로 정렬된다.
----------- 
이어서 우선순위 큐에서 동일한 과정을 반복한다.
거리가 가장 짧은 (1,4)가 추출된다.
1 2 3 4 5 6
0 2 4 1 2 -
우선순위 큐 / (거리:2 노드:2)(거리:2 노드:5)(거리:4 노드:3)(거리:5 노드:3)
----------- 
(2,2)가 뽑히지만 2를 거쳐서 가는 경우 최단 거리가 갱신되지 않는다.
1 2 3 4 5 6
0 2 4 1 2 -
우선순위 큐 / (거리:2 노드:5)(거리:4 노드:3)(거리:5 노드:3)
----------- 
(2,5)가 뽑혀 5를 거쳐 가는 경우를 계산한다.
1 2 3 4 5 6
0 2 3 1 2 4
우선순위 큐 / (거리:3 노드:3)(거리:4 노드:3)(거리:4 노드:6)(거리:5 노드:3)
----------- 
(3,3)을 꺼내 3번 노드를 기준으로 수행하지만 최단 거리는 갱신되지 않는다.
(4,3)을 꺼내 3번 노드를 기준으로 수행해보지만 이미 전에 거리 3으로 3노드를 수행했던 기록이 있기에 무시한다.
(4,6)을 꺼내 6번 노드를 기준으로 수행하더라도 변경되는 점은 없다.
마지막으로 남은 (5,3)을 꺼내보지만 아까 이미 3이라는 거리로 3노드를 수행했었기에 무시한다.   
```

## 플로이드 워셜 알고리즘
다익스트라 알고리즘은 '한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우'에 사용할 수 있는 최단 경로 알고리즘이다.   
이번에 설명하는 플로디으 워셜 알고리즘은 모든 지점에서 다른 모든 지점까지의 최단 경로를 구해야 하는 경우에 사용한다.   
다익스트라 알고리즘에 비하면 구현 코드가 매우 짧아서 어려움을 겪지는 않는다.   
구조를 잘 이해해두자.   
다익스트라 알고리즘은 단계마다 최단 거리를 가지는 노드를 하나씩 반복적으로 선택한다.   
그리고 해당 노드를 거쳐 가는 경로를 확인하며 테이블을 갱신하는 방식으로 동작한다.   
플로이드워셜 알고리즘 또한 동일하게 노드를 거쳐 가는 경로를 확인하지만   
매번 방문하지 않은 노드 중 최단 거리를 갖는 노드를 찾을 필요가 없다는 점이 다르다.   
노드의 개수가 N일때 알고리즘 상으로 N번의 단계를 수행하며, 단계마다 O(N^2)의 연산을 통해 경로를 고려한다.   
따라서 총 시간 복잡도는 O(N^3)이다.   
다익스트라와 다르게 모든 노드에 대하여 다른 모든 노드로 가는 최단 거리 정보를 담기 때문에 2차원 리스트를 작성한다.   
점화식으로 계산한다면 D(ab) = min(D(ab), D(ak) + D(kb)) 이다.   
a = 2, b = 3, k = 1이라면   
2에서 곧바로 3으로 가는 것보다 2에서 1을 거치고 1에서 3으로 가는 값이 더 작다면 갱신해주는 구조이다.   

```
import Foundation

func solution() {
    let INF = 987654321
    let n = Int(readLine()!)!
    let m = Int(readLine()!)!
    var graph = Array(repeating: Array(repeating: INF, count: n+1), count: n+1)
    // 자기 자신에게 가는 거리 0
    for i in 0..<n+1 {
        for j in 0..<n+1 {
            if i == j {
                graph[i][j] = 0
            }
        }
    }
    // 간선 정보를 받아 초기화
    for _ in 0..<m {
        let input = readLine()!.split(separator: " ").map{Int($0)!}
        let (a,b,c) = (input[0],input[1],input[2])
        graph[a][b] = c
    }
    // 3중for문으로 플루이드 워셜 알고리즘 수행
    for k in 1..<n+1 {
        for a in 1..<n+1 {
            for b in 1..<n+1 {
                graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])
            }
        }
    }
    for i in 1..<n+1 {
        for j in 1..<n+1 {
            if graph[i][j] == 987654321 { print("INFINITY", terminator: " ")}
            else { print(graph[i][j], terminator: " ")}
        }
        print()
    }
    
}
solution()
```
구현은 생각보다 쉽다.   
   
## 미래도시   
회사가 모여 있는 공중 미래 도시에 있다.   
공중 미래 도시에는 1번부터 N번까지의 회사가 있는데 특정 회사끼리는 도로를 통해 연결되어있다.   
특정회사가 다른 회사가 도로로 연결되어있다면 정확히 1만큼의 시간으로 이동할 수 있다.   
가능한 한 빨리 1번에서 출발하여 K번 회사를 방문한 뒤 X번 회사로 가는 것이 목표다.   
이때 최소 시간을 계산하는 프로그램을 작성하자.   
   
전형적인 플로이드 워셜 알고리즘 문제이다.   
N의 범위가 100이하이므로 매우 한정적이다.   
따라서 N^3일지라도 해결이 가능하다.   
(1에서 K까지의 최소거리) + (K에서 X까지의 최소 거리)가 정답이다.   
   
## 전보
N개의 도시가 있다. 각 도시는 보내고자 하는 메시지가 있는 경우 다른 도시로 전보를 보내서 다른 도시로 전송할 수 있다.   
C라는 도시에서 위급상황이 생겨 최대한 많은 도시로 메시지를 보내고자 한다.   
도시 C에서 보낸 메시지를 받게 되는 도시의 개수는 총 몇개이며 도시들이 메시지를 받는데 걸리는 시간은 얼마일까?   
   
n과 m의 범위가 충분히 크기에 다익스트라 알고리즘을 이용해 풀 수 있다.   
