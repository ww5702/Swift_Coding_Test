특정 지점까지 가장 빠르게 도달하는 방법을 찾는 알고리즘   
# 가장 빠른 길 찾기
'최단 경로' 알고리즘은 말 그대로 가장 짧은 경로를 찾는 알고리즘이다.   
그래서 '길 찾기' 문제라고도 불린다.   
   
상황에 따라 효율적인 알고리즘이 다른데,   
'한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우'   
'모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우'   
와 같이 다양한 사례가 존재한다.   
최단 경로 문제의 경우 보통 그래프를 통해 표현하는데 각 지점은 그래프에서 '노드'로 표현되고, 지점간 연결된 도로는 '간선'으로 표현된다.   
코테에서는 최단 경로를 모두 출력하는 문제보다는 단순히 최단 거리를 출력하도록 요구하는 문제가 많이 출제된다.   
   
최단 거리 알고리즘은 '다익스트라 최단 경로 알고리즘' / '플로이드 워셜' / '벨만 포드 알고리즘' 이렇게 3개 이다.   
그 중 많이 등장하는 다익스트라, 플로이드 워셜 알고리즘 유형만 다룬다.   
이 두개만 이용해도 최단 경로 문제는 어렵지 않게 해결이 가능하다.   
앞서 배운 그리디 알고리즘과 다이나믹 프로그래밍 알고리즘이 최단 경로 알고리즘에 사용된다는 특징이 있다.   
   
## 다익스트라 최단 경로 알고리즘
그래프에서 여러 개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘이다.   
다익스트라 최단 경로 알고리즘은 '음의 간선'이 없을 떄 정상적으로 작동하는데 0보다 작은 값을 가지는 간선이 없어야 한다는 의미이다.   
기본적으로 다익스트라 알고리즘은 그리디 알고리즘으로 구분된다.   
매번 가장 비용이 적은 노드를 선택하는 과정을 반복하기 때문이다.   
과정은 다음과 같다.   
1. 출발 노드 설정   
2. 최단 거리 테이블을 초기화한다.   
3. 방문하지 않은 노드 중 최단 거리가 짧은 노드를 선택한다.   
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.   
5. 3,4 과정을 반복한다.   
각 노드에 대한 현재까지의 최단 거리 정보를 항상 1차원 리스트에 저장하며 리스트를 계속 갱신한다는 특징이 있다.   
나중에 현재 처리하고 있는 노드와 인접한 노드로 도달하는 더 짧은 경로를 찾으면 '더 짧은 경로가 있으므로 이 경로가 최단 경로야' 라고 판단하는 것이다.   
또한 구현하는 방법은 2가지 이다.   
1. 구현하기 쉽지만 느리게 동작하는 코드   
2. 구현하기 조금 더 까다롭지만 빠르게 동작하는 코드   
당연히 2번을 구현할 수 있을 떄 까지 연습해야 한다.   
   
<img width="430" alt="스크린샷 2023-05-25 오후 5 29 17" src="https://github.com/ww5702/Coding_Test/assets/60501045/b759a30a-9bc3-4a31-9f44-5570aa25f13a">   
   
다음과 같은 그래프가 있을 때 1번 노드가 다른 모든 노드로의 최단 거리를 계산해볼 것이다.   
우선 초기 상태에는 다른 노드로 가는 최단 거리를 '무한'으로 설정한다.   
헷갈리지 않기 위해 '987,654,321'으로도 가능하다.   
1 2 3 4 5 6   
0 무 무 무 무   
-----------   
이제 1번노드를 거쳐 다른 노드로 가는 비용을 계산한다.   
모든 간선을 하나씩 확인하면 된다.   
1 2 3 4 5 6   
0 2 5 1 - -   
-----------   
이후에는 가장 거리가 짧은 노드인 '4'를 선택해 다른 노드로 움직이는 경우를 계산한다.   
1 2 3 4 5 6
0 2 4 1 2 -   
4를 통과해 3으로 이동하는 거리가 4이고 1에서 바로 3으로 이동하는 거리가 5이다.   
더 적은 경로로 이동할 수 있기에 4로 갱신한다.   
또한 4를 통해 5로도 이동할 수 있기에 5도 2로 갱신한다.   
-----------   
이제는 2와 5중에 2를 선택하여 진행한다.   
1에서 2를 통과해 이동하는 경우를 계산하는 것이다.   
보통 거리가 같다면 더 작은 번호를 고른다.   
1 2 3 4 5 6   
0 2 4 1 2 -   
하지만 2를 통과해 이동했을때 경로가 더 단축되는 경우는 없기에   
그래프에 변동사항은 없다.   
-----------   
이제 5가 선택된다.   
1에서 4를 거쳐 5에서 시작되는 과정이다.   
1 2 3 4 5 6   
0 2 3 1 2 4   
3과 6의 경로가 갱신된다.   
-----------   
남은 경로 3, 6중 더 적은 3을 선택한다.   
1 4 5 3의 경로로 움직이는 과정이다.   
1 2 3 4 5 6   
0 2 3 1 2 4   
변동사항은 없다.   
-----------   
마지막 남은 6을 선택하여도 결과는 동일하다.   
따라서 1번노드로부터 출발했을때 각 노드별로 최단 경로로 도착하는 값은   
0 2 3 1 2 4 가 된다.   
   
이제 알고리즘을 실제 구현해보자.   
먼저 말했던 쉽게 구현하는 방법이다.   
O(V^2)의 시간복잡도를 가지는데 여기서 V는 노드의 개수를 말한다.   
