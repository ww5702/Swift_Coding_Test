# 큐와 덱을 구현하고 사용해 봅시다.

## 18258 큐 2
정수를 저장하는 큐를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.   
명령은 총 여섯 가지이다.   
   
1. push X: 정수 X를 큐에 넣는 연산이다.
2. pop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.
3. size: 큐에 들어있는 정수의 개수를 출력한다.
4. empty: 큐가 비어있으면 1, 아니면 0을 출력한다.
5. front: 큐의 가장 앞에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.
6. back: 큐의 가장 뒤에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.
```
import Foundation
func solution() {
    struct Queue {
        var queue: [Int] = []
        var first: Int = 0
        
        public var front: Int {
            return queue[first]
        }
        
        public var backValue: Int {
            return self.queue.last!
        }
        
        public var count: Int {
            return queue.count - first
        }
        
        public var isEmpty: Bool {
            return queue.count - first == 0
        }
        
        public mutating func enqueue(_ element: Int) {
            queue.append(element)
        }
        
        public mutating func dequeue() -> Int {
            guard first <= count else {return -1}
            let element = queue[first]
            queue[first] = -1 // 맨 앞 원소를 nil로 만들기
            first += 1 // head 옮겨주기
            return element
        }
    }
    var myQueue = Queue()
    let n = Int(readLine()!)!
    for _ in 0..<n {
        let input = readLine()!.split(separator: " ").map{String($0)}
        
        switch(input[0]) {
        case "push":
            myQueue.enqueue(Int(input[1])!)
            break
        case "pop":
            print(myQueue.dequeue())
            break
        case "size":
            print(myQueue.count)
            break
        case "empty":
            if myQueue.isEmpty {
                print("1")
            } else {
                print("0")
            }
            break
        case "front":
            print(myQueue.front)
            break
        case "back":
            print(myQueue.backValue)
            break
        default:
            break
        }
    }
}
solution()
```
큐를 구현하여 풀이했지만 에러가 나왔다.   
출력하는 방법은 맞지만 받아내는 readLine을 fileIO로 받아왔어야했다.   
```
final class FileIO {
    private var buffer:[UInt8]
    private var index: Int
    
    init(fileHandle: FileHandle = FileHandle.standardInput) {
        buffer = Array(fileHandle.readDataToEndOfFile())+[UInt8(0)]
        index = 0
    }
    
    @inline(__always) private func read() -> UInt8 {
        defer { index += 1 }
        
        return buffer.withUnsafeBufferPointer { $0[index] }
    }
    
    @inline(__always) func readInt() -> Int {
        var sum = 0
        var now = read()
        var isPositive = true
        
        while now == 10
                || now == 32 { now = read() }
        if now == 45{ isPositive.toggle(); now = read() }
        while now >= 48, now <= 57 {
            sum = sum * 10 + Int(now-48)
            now = read()
        }
        
        return sum * (isPositive ? 1:-1)
    }
    
    @inline(__always) func readString() -> Int {
        var str = 0
        var now = read()
        
        while now == 10
                || now == 32 { now = read() }
        
        while now != 10
                && now != 32 && now != 0 {
            str += Int(now)
            now = read()
        }
        
        return str
    }
}
```
