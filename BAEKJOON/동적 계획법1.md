# 기초적인 동적 계획법 문제들을 풀어봅시다.
## 24416 알고리즘 수업 - 피보나치 수 1
오늘도 서준이는 동적 프로그래밍 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.   
   
오늘은 n의 피보나치 수를 재귀호출과 동적 프로그래밍으로 구하는 알고리즘을 배웠다.    
재귀호출에 비해 동적 프로그래밍이 얼마나 빠른지 확인해 보자.   
아래 의사 코드를 이용하여 n의 피보나치 수를 구할 경우 코드1 코드2 실행 횟수를 출력하자.   
```
let n = Int(readLine()!)!

func fib(_ n : Int) -> Int {
	if n <= 1 { return n }
	return fib(n-1) + fib(n-2)
}

func fibonacci(_ n : Int) -> Int {
	var cache : [Int] = [0,1]
	var cnt = 0
	for i in 2...n {
		cnt += 1
		cache.append(cache[i-1] + cache[i-2])
	}
	return cnt-1
}

print(fib(n), fibonacci(n))
```
DP를 배울 때 가장 처음 배운 예제인 피보나치함수이다.   

## 9184 신나는 함수 실행
재귀 호출만 생각하면 신이 난다! 아닌가요?   
다음과 같은 재귀함수 w(a, b, c)가 있다.   
   
<img width="728" alt="스크린샷 2023-01-26 오후 4 23 20" src="https://user-images.githubusercontent.com/60501045/214779142-828f3e9e-e67b-4899-9594-dc54d004696c.png">   
   
위의 함수를 구현하는 것은 매우 쉽다. 하지만, 그대로 구현하면 값을 구하는데 매우 오랜 시간이 걸린다.   
(예를 들면, a=15, b=15, c=15)   
a, b, c가 주어졌을 때, w(a, b, c)를 출력하는 프로그램을 작성하시오.   
```
var arr : [[[Int]]] = Array(repeating: Array(repeating: Array(repeating: 0, count : 21), count : 21), count : 21)
while true {
	let input = readLine()!.split(separator:" ").map{Int($0)!}
	let (a,b,c) = (input[0],input[1],input[2])
	
	if input == Array(repeating: -1, count : 3) { break; }
	
	func w(_ a : Int, _ b : Int, _ c : Int) -> Int {
		if a <= 0 || b <= 0 || c <= 0 {
			return 1
		} 
		if a > 20 || b > 20 || c > 20 {
			return w(20,20,20)
		} else {
			if arr[a][b][c] == 0 {
				if a < b && b < c {
					arr[a][b][c] = w(a,b,c-1) + w(a,b-1,c-1) - w(a,b-1,c)
				} else {
					arr[a][b][c] = w(a-1,b,c) + w(a-1,b-1,c) + w(a-1,b,c-1) - w(a-1,b-1,c-1)
				}
			}
			return arr[a][b][c]	
		}
	}
	print("w(\(a), \(b), \(c)) = \(w(a,b,c))")
}
```
arr[[[]]] 3차원 배열을 선언하여 하나씩 공식을 대입해주면 되는 문제   
주어진 공식에 20보다 큰 경우는 없으니 배열은 21의 크기로 설정한다.   

## 1904 01타일
지원이에게 2진 수열을 가르쳐 주기 위해, 지원이 아버지는 그에게 타일들을 선물해주셨다.   
그리고 이 각각의 타일들은 0 또는 1이 쓰여 있는 낱장의 타일들이다.   
   
어느 날 짓궂은 동주가 지원이의 공부를 방해하기 위해 0이 쓰여진 낱장의 타일들을 붙여서 한 쌍으로 이루어진 00 타일들을 만들었다.   
결국 현재 1 하나만으로 이루어진 타일 또는 0타일을 두 개 붙인 한 쌍의 00타일들만이 남게 되었다.   
   
그러므로 지원이는 타일로 더 이상 크기가 N인 모든 2진 수열을 만들 수 없게 되었다.   
예를 들어, N=1일 때 1만 만들 수 있고, N=2일 때는 00, 11을 만들 수 있다. (01, 10은 만들 수 없게 되었다.)   
또한 N=4일 때는 0011, 0000, 1001, 1100, 1111 등 총 5개의 2진 수열을 만들 수 있다.   
   
우리의 목표는 N이 주어졌을 때 지원이가 만들 수 있는 모든 가짓수를 세는 것이다. 단 타일들은 무한히 많은 것으로 가정하자.   
```
import Foundation

func solution() {
    let n = Int(readLine()!)!
    var arr = [1,2]
    
    while n > arr.count {
        arr.append((arr[arr.count-1] + arr[arr.count-2]) % 15746)
    }
    print(arr[n-1])
}

solution()
```
## 9461 파도반 수열
오른쪽 그림과 같이 삼각형이 나선 모양으로 놓여져 있다. 첫 삼각형은 정삼각형으로 변의 길이는 1이다.   
그 다음에는 다음과 같은 과정으로 정삼각형을 계속 추가한다.   
나선에서 가장 긴 변의 길이를 k라 했을 때, 그 변에 길이가 k인 정삼각형을 추가한다.   
   
파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이이다.    
P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9이다.   
   
N이 주어졌을 때, P(N)을 구하는 프로그램을 작성하시오.   
   
<img width="267" alt="스크린샷 2023-01-27 오후 4 38 34" src="https://user-images.githubusercontent.com/60501045/215033218-524f2ee2-78c8-49b1-8b04-6f4b77f2c1a7.png">   
   
```
import Foundation

let t = Int(readLine()!)!
func solution() {
    var arr = [1,1,1]
    // (n-2) + (n-3)
    for i in 3...100 {
        arr.append((arr[i-2] + arr[i-3]))
    }
    for _ in 0..<t {
        print(arr[Int(readLine()!)! - 1])
    }
}

solution()
```
파도반 수열의 공식을 찾아낸 다음 해당 배열에 미리 저장시켜둔 후   
원하는 값을 하나하나 뽑아낸다.   

## 1912 연속합
n개의 정수로 이루어진 임의의 수열이 주어진다.   
우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다.    
단, 수는 한 개 이상 선택해야 한다.   
   
예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자.   
여기서 정답은 12+21인 33이 정답이 된다.   
```
let n = Int(readLine()!)!
let arr = readLine()!.split(separator:" ").map{Int($0)!}
var dp = Array(repeating: -1001, count: 1000001)

dp[0] = arr[0]

for i in 1..<n {
    dp[i] = max(arr[i],dp[i-1] + arr[i])
}

print(dp.max()!)
```
dp에 연속적인 합의 값을 누적시켜준다.   

## 1149
RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.   
   
집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다.   
각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.   
   
1번 집의 색은 2번 집의 색과 같지 않아야 한다.   
N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.   
i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.   
```
func solution() -> Int{
    let n = Int(readLine()!)!
    var arr : [[Int]] = [[]]
    var dp = Array(repeating: Array(repeating: 0, count: 4), count: n+1)
    for _ in 0..<n{
        let a = readLine()!.split(separator: " ").map{Int($0)!}
        arr.append(a)
    }
    for i in 1...n {
        dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + arr[i][0]
        dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + arr[i][1]
        dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + arr[i][2]
    }
    return min(dp[n][0], dp[n][1], dp[n][2])
}
print(solution())
```
dp에 3가지 경우의 수를 저장해주는 문제이다.   
1번째 선택한 색을 2번째 집은 고를 수 없으므로
dp[i] = dp[i-1] + min(arr[i]) 이 되는데   
dp[i-1]또한 이미 최소값을 정해서 가져와야 한다는것이다.   
그렇다면 dp[0]을 R일때, G일때, B일때 세가지 경우의 수를 따져가며 마지막에 최소값을 골라준다.   

## 1932 정수 삼각형
   
<img width="144" alt="스크린샷 2023-01-30 오후 4 19 26" src="https://user-images.githubusercontent.com/60501045/215412217-ca02f5a2-6dab-4d7a-8602-d8c7df41551b.png">   
   
위 그림은 크기가 5인 정수 삼각형의 한 모습이다.   
   
맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때,   
이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라.   
아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.   
   
삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.   
```
import Foundation

let n = Int(readLine()!)!
var arr : [[Int]] = [[]]
var dp = Array(repeating: Array(repeating: 0, count: 501), count: 501)
func solution() {
    for _ in 1...n {
        arr.append(readLine()!.split(separator: " ").map{Int($0)!})
    }

    dp[1][0] = arr[1][0]
    for i in 2..<n+1 {
        for j in 0..<arr[i].count {
            if j == 0{
                dp[i][j] = dp[i-1][j] + arr[i][j]
            } else if j == i-1{
                dp[i][j] = dp[i-1][j-1] + arr[i][j]
            } else {
                dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + arr[i][j]
            }
        }
    }
    print(dp[n].max()!)
}

solution()
```
위 문제는 3가지 경우의 수로 풀이할 수 있다.   
[8,1,0]의 경우   
1. 그 전 [3,8]에서 3이 내려오는 즉 왼쪽에서만 내려올수밖에 없는 경우,   
2. 1이 받을 수 있는 [3,8] 양쪽에서 내려올수 있는 경우,   
3. 그 전 [3,8]에서 8이 내려오는 즉 오른쪽에서만 내려올수밖에 없는 경우   
   
따라서 점화식은 이렇게 구성이 된다.   
1. dp[i][j] = dp[i-1][j] + arr[i][j]
2. dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + arr[i][j]
3. dp[i][j] = dp[i-1][j-1] + arr[i][j]

## 2579 계단 오르기
계단 오르기 게임은 계단 아래 시작점부터 계단 꼭대기에 위치한 도착점까지 가는 게임이다.   
<그림 1>과 같이 각각의 계단에는 일정한 점수가 쓰여 있는데 계단을 밟으면 그 계단에 쓰여 있는 점수를 얻게 된다.   
   
<img width="302" alt="스크린샷 2023-01-30 오후 4 51 23" src="https://user-images.githubusercontent.com/60501045/215418518-227d4b6c-77b3-4818-8a7e-2baddbb8c656.png">   
   
예를 들어 <그림 2>와 같이 시작점에서부터 첫 번째, 두 번째, 네 번째, 여섯 번째 계단을 밟아 도착점에 도달하면   
총 점수는 10 + 20 + 25 + 20 = 75점이 된다.   
   
<img width="315" alt="스크린샷 2023-01-30 오후 4 51 32" src="https://user-images.githubusercontent.com/60501045/215418551-77d3d0a6-bbbb-4d5c-9860-dedd1ae23b19.png">   
   
계단 오르는 데는 다음과 같은 규칙이 있다.   
   
1. 계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.   
2. 연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.   
3. 마지막 도착 계단은 반드시 밟아야 한다.   
따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다.   
하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.   

각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.   
```
import Foundation

let n = Int(readLine()!)!
var arr : [Int] = []
var dp = Array(repeating: 0, count: 10)

func solution() {
    for _ in 0..<n {
        arr.append(Int(readLine()!)!)
    }
    dp[0] = arr[0]
    dp[1] = max(arr[0] + arr[1] , arr[1])
    dp[2] = max(arr[0] + arr[2], arr[1] + arr[2])
    
    for i in 3..<n {
        dp[i] = max(arr[i] + arr[i-1] + dp[i-3], arr[i] + dp[i-2])
    }
    print(dp[n-1])
}

solution()

```
해당 문제는 역으로 제일 마지막 계단에서의 경우를 통해 구할 수 있다.   
마지막 계단을 밟을때 그 전계단을 밟고 1계단만 올라서는 경우가 있고,   
마지막 계단을 밟을때 그 전에 한번에 2계단을 올라서는 경우가 있다.   
즉,   
1. 전계단까지의 최대값(n-1) + 마지막계단(n)
2. 전전계단까지의 최대값(n-2) + 마지막계단(n)
   
하지만 연속으로 세계단은 밟을 수 없으니 1번 점화식에 한가지 조건을 추가해준다.   
1. 전전전계단까지의 최대값(n-3) + 전계단(n-1) + 마지막계단   
   
두 경우의 수를 정리하면   
dp[i] = max(arr[i] + arr[i-1] + dp[i-3], arr[i] + dp[i-2])   
으로 
