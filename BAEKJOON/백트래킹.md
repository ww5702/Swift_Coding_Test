# 모든 경우를 탐색하는 백트래킹 알고리즘을 배워 봅시다.
백 트래킹이란 탐색하는데 필요한 많은 자원을 줄이기 위해 유망성 있는 노드들을 중심으로 탐색하는 방법이다.   
조건을 줘서 필요없는 노드에는 방문조차 하지 않는다.   
DFS를 이용한다고 생각하면 된다.   

## 15649 N과 M (1)
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.   
- 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열   
```
let input = readLine()!.split(separator:" ").map{Int($0)!}
let (n,m) = (input[0], input[1])

var visited = Array(repeating:false, count: n+1)
var depth: Int = 0
var stack: [Int] = []

func solution(depth: Int) {
	if depth == m {
		print(stack.map{String($0)}.joined(separator:" "))
		return
	} else {
		for i in 1...n {
			if !visited[i] {
				visited[i] = true
				stack.append(i)
				solution(depth: depth + 1)
				visited[i] = false
				stack.removeLast()
			}
		}
	}
}

solution(depth : depth)
```
수학에서 수열(數列) 또는 열(列, sequence)은 수 또는 다른 대상의 순서 있는 나열이다.   
수열을 만들되, 백트래킹을 이용하여 중복되는 수를 방문하지 않는다.
DFS를 사용하기 때문에 스택을 활용한다.   

## 15650 N과 M (2)
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.   
- 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열.   
- 고른 수열은 오름차순이어야 한다.    
```
let input = readLine()!.split(separator:" ").map{Int($0)!}
let (n,m) = (input[0], input[1])

var visited = Array(repeating:false, count: n+1)
var depth: Int = 0
var stack: [Int] = []

func solution(depth: Int) {
	if depth == m {
		if stack.sorted() == stack {
			print(stack.map{String($0)}.joined(separator:" "))
			return
		}
	} else {
		for i in 1...n {
			if !visited[i] {
				visited[i] = true
				stack.append(i)
				solution(depth: depth + 1)
				visited[i] = false
				stack.removeLast()
			}
		}
	}
}

solution(depth : depth)
```
첫 번째 문제에서 오름차순일 경우라는 조건만 추가된 문제이다.   
구한 stack 배열이 stack.sorted와 일치 하는 경우에만 출력해준다면 된다.   

## 15651 N과 M (3)
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.   
- 1부터 N까지 자연수 중에서 M개를 고른 수열.   
- 같은 수를 여러 번 골라도 된다.   
```
let input = readLine()!.split(separator:" ").map{Int($0)!}
let (n,m) = (input[0], input[1])

var depth: Int = 0
var stack: [Int] = []

func solution(depth: Int) {
	if depth == m {
		print(stack.map{String($0)}.joined(separator:" "))
		return
	} else {
		for i in 1...n {
			stack.append(i)
			solution(depth: depth + 1)
			stack.removeLast()
		}
	}
}

solution(depth : depth)
```
쉽게 생각해서 [1,1,1,1]은 i가 1일때 전부 들어가는것이다.   
1을 depth가 m이 될때까지 stack에 추가해주고(1,1,1,1) 이 stack을 출력, 그리고 마지막노드를 삭제한다.   
그리고 2를 append 그리고 다시 출력   
근데 시간초과;   
검색해보니 print를 매번해주는것이 시간초과라고 한다...   
```
let input = readLine()!.split(separator:" ").map{Int($0)!}
let (n,m) = (input[0], input[1])

var depth: Int = 0
var stack: [Int] = []
var str = ""

func solution(depth: Int) {
	if depth == m {
		str += stack.map{String($0)}.joined(separator:" ")
		str += "\n"
		return
	} else {
		for i in 1...n {
			stack.append(i)
			solution(depth: depth + 1)
			stack.removeLast()
		}
	}
}

solution(depth : depth)
print(str)
```
따라서 str하나에 stack을 저장해준다음 나중에 한번에 출력해주었다.   
## 15652 N과 M (4)
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.   
   
- 1부터 N까지 자연수 중에서 M개를 고른 수열   
- 같은 수를 여러 번 골라도 된다.   
- 고른 수열은 비내림차순이어야 한다.   
(길이가 K인 수열 A가 A1 ≤ A2 ≤ ... ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.)   
```
let input = readLine()!.split(separator:" ").map{Int($0)!}
let (n,m) = (input[0], input[1])

var depth: Int = 0
var stack: [Int] = []
var str = ""

func solution(depth: Int) {
	if depth == m {
		if stack.sorted() == stack {
			str += stack.map{String($0)}.joined(separator:" ")
			str += "\n"
			return
		}
	} else {
		for i in 1...n {
			stack.append(i)
			solution(depth: depth + 1)
			stack.removeLast()
		}
	}
}

solution(depth : depth)
print(str)
```
전 문제와 전전 문제를 합친것이라 생각해 이렇게 풀었는데   
답은 같게 나왔지만 시간초과   
```
let input = readLine()!.split(separator:" ").map{Int($0)!}
let (n,m) = (input[0], input[1])

var str = ""

func solution(currentValue: Int, count: Int, str: String) {
	if count == m {
		print(str)
		return
	}
	for i in currentValue...n {
		solution(currentValue: i, count: count+1, str: str+"\(i) ")
	}
}

solution(currentValue: 1, count: 0, str: str)
```
과정을 좀더 생략해서 만들었다.   
## 9663 N-Queen
N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.   
N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.   
```
func solution(_ n:Int) -> Int {

    func nqueen(rightDown: Int, lookDown: Int, leftDown: Int) {
        // 퀸을 모두 놓을 수 있는 경우
        if lookDown == done {
            count += 1
            return
        }
        // 충돌 체크
        // 왼쪽 대각, 오른쪽 대각, 정면을 합해서 구한다.
        // 이후 연산을 위해 미리 보수를 취한다.
        var poss = ~(rightDown | lookDown | leftDown)

        // 비여있는 자리 있는지 체크
        // 놓을 수 있는 곳이 없을 때 까지 반복한다.
        while (poss & done) != 0 {
            
            // 빈자리의 위치를 구한다.
            let bit = poss & -poss
            
            // 퀸을 놓은 위치를 더해준다.
            poss -= bit
            
            // 왼쪽, 오른쪽 대각선은 비트와 논리합을 해준 뒤 한칸씩 시프트 한다.
            // 정면은 비트와 논리합만 해줘도 된다.
            nqueen(rightDown: (rightDown | bit)>>1, lookDown: (lookDown | bit), leftDown: (leftDown | bit)<<1)
        }
    }
    
    let done = 1<<n - 1
    var count = 0
    nqueen(rightDown: 0, lookDown: 0, leftDown: 0)
    return count
}

let n = Int(readLine()!)!
print(solution(n))
```
백트래킹 수행하여 풀이   
