```
/*
그저 재귀함수로 f(n-2) + f(n-1)을 해주지않고
동적계획법 dp로 풀이하면 시간복잡도를 더 줄일 수 있다.
append부분에서 1234567을 나누지않고 append해주고
반환 부분에서 %1234567을 해주었더니 오류가 발생하였다.   

따라서 질문하기 게시판에 들어가보니 나와 같은 오류가 발생한 사람이 있었고 그에 대한 답변은 이와 같다.
n이 매우 큰 경우 n번째 피보나치 수는 언어가 표현할 수 있는 자료형의 범위를 넘어가, 오버플로우가 납니다. 
예를 들어 47번째 피보나치 수는 2,971,215,073이고, 이 수는 32비트 정수(ex. int) 범위를 넘어 오버플로우가 발생합니다. 
100,000번째 피보나치 수는 자릿수가 20,000을 넘어가며, 이는 64비트 정수(ex. long) 범위를 넘어 오버플로우가 발생합니다. 

즉 수가 너무 커지므로 Int 정수 범위를 넘어서게 되고 오버플로우가 발생하게되므로 미리 나눠준 뒤 append를 해준다면 해결이 된다.

*/
func solution(_ n:Int) -> Int {
    var cache: [Int] = [0,1]
    func fibo(_ n: Int) -> Int{
        guard n > 1 else { return n }
        for num in 2...n {
            cache.append((cache[num-2] + cache[num-1])%1234567)
        }
        return cache[n]
    }
    return fibo(n)
}
```
