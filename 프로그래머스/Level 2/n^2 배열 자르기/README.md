첫 제출   
이 문제는 규칙만 유심히 지켜본다면 쉽게 풀 수 있다.   
첫번째 테스트케이스는   
(0,0) -> 1   
(0,1) (1,0) (1,1) -> 2   
(0,2) (2,0) (2,1) (2,2) -> 3   
의 숫자가 배정되는데 이는 (i,j)일때 i,j의 최댓값 +1이 배정된다는 규칙을 찾을 수 있다.   
또한 주어진 수는 최대 10^7이므로 시간복잡도 O(N^2)로는 풀 수 없다는 사실을 알 수 있다.   
따라서 left...right의 배열을 따로 빼내어 left가 (i,j)로 변경된다면 어떻게 바뀌는지에 따라 배열을 입력해주면된다.   
i는 left/n , j는 left%n이다.   그리고 최댓값 +1을 해준다.   

```
import Foundation

func solution(_ n:Int, _ left:Int64, _ right:Int64) -> [Int] {
    // 00
    // 01 10 11
    // 02 12 20 21 22
    // 1 2 3  / 2 2 3  / 3 3 3
    // 1 2 3 4 / 2 2 3 4  / 3 3 3 4  / 4 4 4 4
    // 1 2 3 4 5 / 2 2 3 4 5 / 3 3 3 4 5 / 4 4 4 4 5 / 5 5 5 5
    // for i in Int(left)...Int(right) {
    //     print(i/n+1, i%n+1)
    // }
    let arr: [Int] = (Int(left)...Int(right)).map {
        max($0 / n + 1, $0 % n + 1)
    }
    //print(arr)
    return arr
}
```
